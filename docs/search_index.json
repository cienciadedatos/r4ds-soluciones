[["index.html", "R para Ciencia de Datos: Soluciones de los ejercicios Bienvenida", " R para Ciencia de Datos: Soluciones de los ejercicios Riva Quiroga Mauricio ‘Pachá’ Vargas Gabriela Sandoval Bienvenida ¡Hola! Esta es una versión en desarrollo de las soluciones de los ejercicios que se proponen en R para Ciencia de Datos "],["introducción.html", "1 Introducción", " 1 Introducción ¡Hola! Esta es una versión en desarrollo de las soluciones de los ejercicios que se proponen en R para Ciencia de Datos. "],["introducción-1.html", "2 Introducción", " 2 Introducción Esta sección no tiene ejercicios. "],["visualización-de-datos.html", "3 Visualización de datos 3.1 Introducción 3.2 Primeros pasos 3.3 Mapeos estéticos 3.5 Separar en facetas 3.6 Objetos geométricos 3.7 Transformaciones estadísticas 3.8 Ajustes de posición 3.9 Sistemas de coordenadas", " 3 Visualización de datos 3.1 Introducción library(tidyverse) library(datos) 3.2 Primeros pasos 3.2.4 Ejercicios Corre ggplot(data = millas). ¿Qué observas? Solución ggplot(data = millas) Este código crea un gráfico “vacío”. Solo se ve el fondo, pero no se dibuja nada sobre él porque no se han especificado las otras dos capas mínimas: aes() para mapear las variables y geom_*() para indicar la representación gráfica a utilizar. ¿Cuántas filas hay en millas? ¿Cuántas columnas? Solución Para contar el número de filas y columas podemos utilizar las funciones nrow() y ncol() del paquet dplyr: nrow(millas) #&gt; [1] 234 ncol(millas) #&gt; [1] 11 Hay 234 filas y 11 columnas en el dataset millas. Otra manera de ver el número de filas y de columnas es imprimiendo el objeto en la consola. Al inicio nos indicará el tipo de objeto que es y sus dimensiones en términos de filas x columnas. Algo parecido ocurrirá su utilizamos str(). Si usamos glimpse() nos indicará esta información como número de obervaciones y número de variables millas #&gt; # A tibble: 234 × 11 #&gt; fabricante modelo cilindrada anio cilindros transmision traccion ciudad #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 audi a4 1.8 1999 4 auto(l5) d 18 #&gt; 2 audi a4 1.8 1999 4 manual(m5) d 21 #&gt; 3 audi a4 2 2008 4 manual(m6) d 20 #&gt; 4 audi a4 2 2008 4 auto(av) d 21 #&gt; 5 audi a4 2.8 1999 6 auto(l5) d 16 #&gt; 6 audi a4 2.8 1999 6 manual(m5) d 18 #&gt; # … with 228 more rows, and 3 more variables: autopista &lt;int&gt;, #&gt; # combustible &lt;chr&gt;, clase &lt;chr&gt; str(millas) #&gt; tibble [234 × 11] (S3: tbl_df/tbl/data.frame) #&gt; $ fabricante : chr [1:234] &quot;audi&quot; &quot;audi&quot; &quot;audi&quot; &quot;audi&quot; ... #&gt; $ modelo : chr [1:234] &quot;a4&quot; &quot;a4&quot; &quot;a4&quot; &quot;a4&quot; ... #&gt; $ cilindrada : num [1:234] 1.8 1.8 2 2 2.8 2.8 3.1 1.8 1.8 2 ... #&gt; $ anio : int [1:234] 1999 1999 2008 2008 1999 1999 2008 1999 1999 2008 ... #&gt; $ cilindros : int [1:234] 4 4 4 4 6 6 6 4 4 4 ... #&gt; $ transmision: chr [1:234] &quot;auto(l5)&quot; &quot;manual(m5)&quot; &quot;manual(m6)&quot; &quot;auto(av)&quot; ... #&gt; $ traccion : chr [1:234] &quot;d&quot; &quot;d&quot; &quot;d&quot; &quot;d&quot; ... #&gt; $ ciudad : int [1:234] 18 21 20 21 16 18 18 18 16 20 ... #&gt; $ autopista : int [1:234] 29 29 31 30 26 26 27 26 25 28 ... #&gt; $ combustible: chr [1:234] &quot;p&quot; &quot;p&quot; &quot;p&quot; &quot;p&quot; ... #&gt; $ clase : chr [1:234] &quot;compacto&quot; &quot;compacto&quot; &quot;compacto&quot; &quot;compacto&quot; ... glimpse(millas) #&gt; Rows: 234 #&gt; Columns: 11 #&gt; $ fabricante &lt;chr&gt; &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;a… #&gt; $ modelo &lt;chr&gt; &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4 quattro&quot;, &quot;a… #&gt; $ cilindrada &lt;dbl&gt; 1.8, 1.8, 2.0, 2.0, 2.8, 2.8, 3.1, 1.8, 1.8, 2.0, 2.0, 2.8… #&gt; $ anio &lt;int&gt; 1999, 1999, 2008, 2008, 1999, 1999, 2008, 1999, 1999, 2008… #&gt; $ cilindros &lt;int&gt; 4, 4, 4, 4, 6, 6, 6, 4, 4, 4, 4, 6, 6, 6, 6, 6, 6, 8, 8, 8… #&gt; $ transmision &lt;chr&gt; &quot;auto(l5)&quot;, &quot;manual(m5)&quot;, &quot;manual(m6)&quot;, &quot;auto(av)&quot;, &quot;auto(… #&gt; $ traccion &lt;chr&gt; &quot;d&quot;, &quot;d&quot;, &quot;d&quot;, &quot;d&quot;, &quot;d&quot;, &quot;d&quot;, &quot;d&quot;, &quot;4&quot;, &quot;4&quot;, &quot;4&quot;, &quot;4&quot;, &quot;4&quot;… #&gt; $ ciudad &lt;int&gt; 18, 21, 20, 21, 16, 18, 18, 18, 16, 20, 19, 15, 17, 17, 15… #&gt; $ autopista &lt;int&gt; 29, 29, 31, 30, 26, 26, 27, 26, 25, 28, 27, 25, 25, 25, 25… #&gt; $ combustible &lt;chr&gt; &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;… #&gt; $ clase &lt;chr&gt; &quot;compacto&quot;, &quot;compacto&quot;, &quot;compacto&quot;, &quot;compacto&quot;, &quot;compacto&quot;… ¿Qué describe la variable traccion? Lee la ayuda de ?millas para encontrar la respuesta. Solución traccion esa una variable categórica que clasifica los vehículos en tracción delantera, trasera o de cuatro ruedas. unique(millas$traccion) #&gt; [1] &quot;d&quot; &quot;4&quot; &quot;t&quot; Realiza un gráfico de dispersión de autopista versus cilindros. Solución ggplot(millas, aes(x = autopista, y = cilindros)) + geom_point() ¿Qué sucede cuando haces un gráfico de dispersión de clase versus traccion? ¿Por qué no es útil este gráfico? Solución El gráfico resultante tiene pocos puntos. Ambas variables son categóricas y por lo tanto existe una cantidad limitada de combinaciones posibles. ggplot(millas, aes(x = clase, y = traccion)) + geom_point() Otro problema es la frecuencia de combinaciones posibles no es la misma en todos los casos. count(millas, traccion, clase) #&gt; # A tibble: 12 × 3 #&gt; traccion clase n #&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 4 compacto 12 #&gt; 2 4 mediano 3 #&gt; 3 4 pickup 33 #&gt; 4 4 subcompacto 4 #&gt; 5 4 suv 51 #&gt; 6 d compacto 35 #&gt; # … with 6 more rows Los gráficos de dispersión debieran usarse con variables continuas y cuando los valores son únicos. 3.3 Mapeos estéticos 3.3.1 Ejercicios ¿Qué no va bien en este código? ¿Por qué hay puntos que no son azules? ggplot(data = millas) + geom_point(mapping = aes(x = cilindrada, y = autopista, color = &quot;blue&quot;)) Solución Se incluyó el color dentro de aes(), por lo cual se trata como una variable, lo cual sería útil si tuvieramos una columna con información de los colores. Para dejar todos los puntos en color azul, se debe cambiar el orden de los parámetros. ggplot(data = millas) + geom_point(mapping = aes(x = cilindrada, y = autopista), color = &quot;blue&quot;) ¿Qué variables en millas son categóricas? ¿Qué variables son continuas? (Sugerencia: escribe ?millas para leer la documentación de ayuda para este conjunto de datos). ¿Cómo puedes ver esta información cuando ejecutas millas? Solución Variables categóricas: modelo, transmisión, tracción, combustible y clase. Variables continuas: cilindrada, año, cilindros, ciudad, autopista. Asigna una variable continua a color, size, y shape. ¿Cómo se comportan estas estéticas de manera diferente para variables categóricas y variables continuas? Solución Una posibilidad es graficar rendimiento de combustible en autopista dado el tipo de motor. Como información adicional usamos el rendimiento en ciudad como color, de modo de contar con una paleta de colores informativa. ggplot(millas, aes(x = cilindrada, y = autopista, colour = ciudad)) + geom_point() Los otros casos quedan como ejercicio. ¿Qué ocurre si asignas o mapeas la misma variable a múltiples estéticas? Solución R va a generar un gráfico con información redundante, lo cual se debiera evitar. ggplot(millas, aes(x = cilindrada, y = autopista, colour = autopista, size = autopista)) + geom_point() ¿Qué hace la estética stroke? ¿Con qué formas trabaja? (Sugerencia: consultar ?geom_point) Solución Cambia el tamaño de los bordes de las formas 21 a 25. Para estas formas es posible cambiar el color de relleno y borde y también el tamaño de los bordes. Ejemplo: ggplot(mtautos, aes(peso, millas)) + geom_point(shape = 21, colour = &quot;black&quot;, fill = &quot;white&quot;, size = 5, stroke = 5) ¿Qué ocurre si se asigna o mapea una estética a algo diferente del nombre de una variable, como ser aes(color = cilindrada &lt; 5)? Solución R crea una variable temporal que da cuenta de la evaluación de la variable. En el caso de cilindrada &lt; 5 el resultado es verdadero o falso y según esto se incluyen los colores en el gráfico. Ejemplo: ggplot(millas, aes(x = cilindrada, y = autopista, colour = cilindrada &lt; 5)) + geom_point() 3.5 Separar en facetas 3.5.1 Ejercicios Qué ocurre si intentas separar en facetas a una variable continua? Solución Veamos un ejemplo: ggplot(millas, aes(x = cilindros, y = autopista)) + geom_point() + facet_grid(. ~ ciudad) La variable continua es convertida a una variable categórica y el gráfico contiene una faceta para cada valor, ¿Qué significan las celdas vacías que aparecen en el gráfico generado usando facet_grid(traccion ~ cilindros)? ¿Cómo se relacionan con este gráfico? ggplot(data = millas) + geom_point(mapping = aes(x = traccion, y = cilindros)) Solución ggplot(data = millas) + geom_point(mapping = aes(x = autopista, y = ciudad)) + facet_grid(traccion ~ cilindros) Las celdas vacías (facetas) en este gráfico corresponden a combinaciones de traccion y cilindros que no tienen observaciones. Son las mismas ubicaciones en el gráfico de dispersión de autopista y ciudad que no tienen gráfica. ggplot(data = millas) + geom_point(mapping = aes(x = autopista, y = ciudad)) ¿Qué gráfica el siguiente código? ¿Qué hace . ? ggplot(data = millas) + geom_point(mapping = aes(x = cilindrada, y = autopista)) + facet_grid(traccion ~ .) ggplot(data = millas) + geom_point(mapping = aes(x = cilindrada, y = autopista)) + facet_grid(. ~ cilindros) Solución El símbolo . ignora la dimensión al momento de dibujar las facetas. Por ejemplo, autopista ~ . divide por los valores de autopista en el eje y. ggplot(data = millas) + geom_point(mapping = aes(x = cilindrada, y = autopista)) + facet_grid(traccion ~ .) A la vez, . ~ cilindrada va a dividir por los valores de cyl en el eje x. ggplot(data = millas) + geom_point(mapping = aes(x = cilindrada, y = autopista)) + facet_grid(. ~ cilindros) Mira de nuevo el primer gráfico en facetas presentado en esta sección: ggplot(data = millas) + geom_point(mapping = aes(x = cilindrada, y = autopista)) + facet_wrap(~ clase, nrow = 2) ¿Cuáles son las ventajas de separar en facetas en lugar de aplicar una estética de color? ¿Cuáles son las desventajas? ¿Cómo cambiaría este balance si tuvieras un conjunto de datos más grande? Solución En el siguiente gráfico muestra la variable clase como color. ggplot(data = millas) + geom_point(mapping = aes(x = cilindrada, y = autopista, color = clase)) La ventaja de usar clase como parte de las facetas en lugar de un argumento de color es la posibilidad de incluir distintas categorías. Es difícil distinguir entre los colores de las categorías “mediano” y “minivan”. De acuerdo a las reglas de percepción, no se debería usar más de nueve colores para mostrar información cualitativa. Mostrar observaciones de distintas categorías en diferentes escalaes hace que sea difícil comparar directamente entre los valores de distintas categorías. Sin embargo, haría más fácil comparar la forma de la relación entre x e y en distintas categorías. La desventaja de usar clase para las facetas en lugar del argumento de color es la dificultad de comparar valores entre categorías dado que las observaciones para cada categoría se ubican en distintos gráficos. Usando las mismas escalas para los ejes x e y en todas las facetas facilita comparar observaciones entre categorías, pero sigue siendo una comparación más compleja respecto del caso en que todas las observaciones se ubican en el mismo gráfico. Dado que usar clase para el argumento de color sitúa todos los puntos en un mismo gráfico, muestra la relación incondicional entre las variables x e y, lo que no ocurre al separar en distintos gráficos. Los beneficios de codificar una variable mediante el color son crecientes si aumenta la cantidad de observaciones o el número de categorías. Si aumenta el número de categorías puede haber superposición y resulta complejo manejar esto con argumentos de color a menos que el número de observaciones sea pequeño y se pueda usar un argumento de distorsión (jitter). El argumento de transparencia (alpha) no funciona bien con colores ya que la combinación de colores producto de la superposición no representa adecuadamente las categorías. Si aumenta mucho el número de categorías va a ser cada vez más difícil contar con colores distintivos y será difícil distinguirlos. Lee ?facet_wrap. ¿Qué hace nrow? ¿Qué hace ncol? ¿Qué otras opciones controlan el diseño de los paneles individuales? ¿Por qué facet_grid() no tiene argumentos nrow y ncol? Solución Los argumentos nrow y ncol determinan el número de filas y columnas al momento de generar las facetas. facet_wrap() opera sobre una única variable. nrow y ncol no son necesarios con facet_grid ya que el número de valores únicos en la función determina el número de filas y columnas. Cuando usas facet_grid(), generalmente deberías poner la variable con un mayor número de niveles únicos en las columnas. ¿Por qué? Solución Hacerlo genera más espacio para las columnas si el gráfico se ubica de forma horizontal. 3.6 Objetos geométricos 3.6.1 Ejercicios ¿Qué geom usarías para generar un gráfico de líneas? ¿Un diagrama de caja? ¿Un histograma? ¿Un gráfico de área? Solución gráfico de líneas: geom_line() diagrama de caja: geom_boxplot() histograma: geom_histogram() gráfico de área: geom_area() Ejecuta este código en tu mente y predice cómo se verá el output. Luego, ejecuta el código en R y verifica tus predicciones. ggplot(data = millas, mapping = aes(x = cilindrada, y = autopista, color = traccion)) + geom_point() + geom_smooth(se = FALSE) Solución El resultado es un diagrama de dispersión con cilindrada en el eje x, autopista en el eje y y los puntos pintados de acuerdo a traccion. También se incluirá una línea de tendencia, sin el error estándar, para cada grupo de traccion. ggplot(data = millas, mapping = aes(x = cilindrada, y = autopista, colour = traccion)) + geom_point() + geom_smooth(se = FALSE) #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; ¿Qué muestra show.legend = FALSE? ¿Qué pasa si lo quitas? ¿Por qué crees que lo usé antes en el capítulo? Solución show.legend = FALSE oculta la leyenda. Considera el siguiente ejemplo ya visto: ggplot(data = millas) + geom_smooth( mapping = aes(x = cilindrada, y = autopista, colour = traccion), show.legend = FALSE ) #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; Quitar el argumento show.legend o definir show.legend = TRUE mostrará la relación entre traccion y la paleta de colores. ggplot(data = millas) + geom_smooth(mapping = aes(x = cilindrada, y = autopista, colour = traccion)) #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; En el capítulo, la leyenda se suprime ya que con tres gráficos, agregar una leyenda al tercero hará que se vea de distinto tamaño. Dejar los gráficos de distinto tamaño dificulta ver cómo los argumentos cambian la apariencia de los gráficos. La finalidad de estos gráficos es mostrar la diferencia sin grupos, usando una estética de grupo y usando una estética de color, lo cual crea grupos implícitos. En el ejemplo, la leyenda no es necesaria ya que buscar los valores asociados a cada valor no ayuda a evidenciar los datos. ¿Qué hace el argumento se en geom_smooth()? Solución Agrega las bandas de error estándar a las líneas. ggplot(data = millas, mapping = aes(x = cilindrada, y = autopista, colour = traccion)) + geom_point() + geom_smooth(se = TRUE) #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; Por defecto la opción es se = TRUE: ggplot(data = millas, mapping = aes(x = cilindrada, y = autopista, colour = traccion)) + geom_point() + geom_smooth() #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; ¿Se verán distintos estos gráficos? ¿Por qué sí o por qué no? ggplot(data = millas, mapping = aes(x = cilindrada, y = autopista)) + geom_point() + geom_smooth() ggplot() + geom_point(data = millas, mapping = aes(x = cilindrada, y = autopista)) + geom_smooth(data = millas, mapping = aes(x = cilindrada, y = autopista)) Solución No. geom_point() y geom_smooth() toman los datos y estéticas de ggplot(), por lo que no hace falta especificar lo mismo dos veces. ggplot(data = millas, mapping = aes(x = cilindrada, y = autopista)) + geom_point() + geom_smooth() #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; ggplot() + geom_point(data = millas, mapping = aes(x = cilindrada, y = autopista)) + geom_smooth(data = millas, mapping = aes(x = cilindrada, y = autopista)) #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; Recrea el código R necesario para generar los siguientes gráficos: Solución ggplot(data = millas, mapping = aes(x = cilindrada, y = autopista)) + geom_point() + geom_smooth(se = FALSE) ggplot(data = millas, mapping = aes(x = cilindrada, y = autopista)) + geom_smooth(aes(group = traccion), se = FALSE) + geom_point() ggplot(data = millas, mapping = aes(x = cilindrada, y = autopista, color = traccion)) + geom_point() + geom_smooth(se = FALSE) ggplot(data = millas, mapping = aes(x = cilindrada, y = autopista)) + geom_point(aes(color = traccion)) + geom_smooth(se = FALSE) ggplot(data = millas, mapping = aes(x = cilindrada, y = autopista)) + geom_point(aes(color = traccion)) + geom_smooth(aes(linetype = traccion), se = FALSE) #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; ggplot(data = millas, mapping = aes(x = cilindrada, y = autopista)) + geom_point(size = 4, colour = &quot;white&quot;) + geom_point(aes(colour = traccion)) 3.7 Transformaciones estadísticas 3.7.1 Ejercicios ¿Cuál es el geom predeterminado asociado con stat_summary()? ¿Cómo podrías reescribir el gráfico anterior para usar esa función geom en lugar de la función stat? Solución El gráfico anterior es el siguiente: ggplot(data = diamantes) + stat_summary( mapping = aes(x = corte, y = profundidad), fun.ymin = min, fun.ymax = max, fun.y = median ) #&gt; Warning: `fun.y` is deprecated. Use `fun` instead. #&gt; Warning: `fun.ymin` is deprecated. Use `fun.min` instead. #&gt; Warning: `fun.ymax` is deprecated. Use `fun.max` instead. La geometría por defecto para stat_summary() es geom_pointrange(). El estadístico por defecto para geom_pointrange() es identity() pero se puede incluir el argumento stat = \"summary\" para usar stat_summary() en lugar de stat_identity(). ggplot(data = diamantes) + geom_pointrange( mapping = aes(x = corte, y = profundidad), stat = &quot;summary&quot; ) #&gt; No summary function supplied, defaulting to `mean_se()` El mensaje resultante en stat_summary() indica que se usó mean y sd para calcular el centro y los extremos de la línea. Sin embargo, en el gráfico original se usaron el máximo y mínimo para los extremos. Para recrear el gráfico original hay que especificar los valores de fun.ymin, fun.ymax, y fun.y. ggplot(data = diamantes) + geom_pointrange( mapping = aes(x = corte, y = profundidad), stat = &quot;summary&quot;, fun.ymin = min, fun.ymax = max, fun.y = median ) #&gt; Warning: Ignoring unknown parameters: fun.ymin, fun.ymax, fun.y #&gt; No summary function supplied, defaulting to `mean_se()` ¿Qué hace geom_col()? ¿Cómo es diferente a geom_bar()? Solución El estadístico por defecto en geom_col() es distinto de geom_bar(). geom_col() usa stat_identity(), que deja los datos sin transformar. geom_col() espera que los datos contengan los valores de x y los valores de y que representan la altura de las columnas. geom_bar() usa stat_bin() y espera únicamente los valores de x. stat_bin(), procesa los datos de entrada y realiza un conteo del número de observaciones para cada valor de x, lo cual genera la variable y internamente. La mayoría de los geoms y las estadísticas vienen en pares que casi siempre se usan en conjunto. Lee la documentación y has una lista de todos los pares. ¿Qué tienen en común? Solución Las siguiente tabla contienen los pares entre geometrías y estadísticos que se usan en conjunto. geometría estadístico geom_bar() stat_count() geom_bin2d() stat_bin_2d() geom_boxplot() stat_boxplot() geom_contour() stat_contour() geom_count() stat_sum() geom_density() stat_density() geom_density_2d() stat_density_2d() geom_hex() stat_hex() geom_freqpoly() stat_bin() geom_histogram() stat_bin() geom_qq_line() stat_qq_line() geom_qq() stat_qq() geom_quantile() stat_quantile() geom_smooth() stat_smooth() geom_violin() stat_violin() geom_sf() stat_sf() Tabla: Geometrías y estadísticos complementarios Los nombres tienen a ser similares, por ejemplo geom_smooth() y stat_smooth(), aunque hay casos como geom_bar() y stat_count(). La mayoría de las geometrías usa por defecto el estadístico que le corresponde en la tabla anterior. Recíprocamente, la mayoría de los estadísticos usan por defecto la geometría que le corresponde en la tabla anterior. Las siguientes tablas contienen las geometrías y estadísticos en ggplot2. geometría estadístico por defecto documentación conjunta geom_abline() geom_hline() geom_vline() geom_bar() stat_count() x geom_col() geom_bin2d() stat_bin_2d() x geom_blank() geom_boxplot() stat_boxplot() x geom_countour() stat_countour() x geom_count() stat_sum() x geom_density() stat_density() x geom_density_2d() stat_density_2d() x geom_dotplot() geom_errorbarh() geom_hex() stat_hex() x geom_freqpoly() stat_bin() x geom_histogram() stat_bin() x geom_crossbar() geom_errorbar() geom_linerange() geom_pointrange() geom_map() geom_point() geom_map() geom_path() geom_line() geom_step() geom_point() geom_polygon() geom_qq_line() stat_qq_line() x geom_qq() stat_qq() x geom_quantile() stat_quantile() x geom_ribbon() geom_area() geom_rug() geom_smooth() stat_smooth() x geom_spoke() geom_label() geom_text() geom_raster() geom_rect() geom_tile() geom_violin() stat_ydensity() x geom_sf() stat_sf() x Tabla: ggplot2 capas de geometrías y sus estadísticos por defecto. estadístico geometría por defecto documentación conjunta stat_ecdf() geom_step() stat_ellipse() geom_path() stat_function() geom_path() stat_identity() geom_point() stat_summary_2d() geom_tile() stat_summary_hex() geom_hex() stat_summary_bin() geom_pointrange() stat_summary() geom_pointrange() stat_unique() geom_point() stat_count() geom_bar() x stat_bin_2d() geom_tile() x stat_boxplot() geom_boxplot() x stat_countour() geom_contour() x stat_sum() geom_point() x stat_density() geom_area() x stat_density_2d() geom_density_2d() x stat_bin_hex() geom_hex() x stat_bin() geom_bar() x stat_qq_line() geom_path() x stat_qq() geom_point() x stat_quantile() geom_quantile() x stat_smooth() geom_smooth() x stat_ydensity() geom_violin() x stat_sf() geom_rect() x Tabla: ggplot2 capas de estadísticos y sus geometrías por defecto. ¿Qué variables calcula stat_smooth()? ¿Qué parámetros controlan su comportamiento? Solución La función stat_smooth() calcula las siguientes variables: y: valor predicho ymin: menor valor del intervalo de confianza ymax: mayor valor del intervalo de confianza se: error estándar La sección “Computed Variables” en la documentación de stat_smooth() contiene estas variables. Los parámetros que controlan stat_smooth() incluyen method: cuál método utilizar formula: las fórmulas, al igual que method, determinan cómo se hará el cálculo del intervalo de confianza y los argumentos adicionales que se requieran. na.rm: si acaso se eliminarán los casos perdidos En nuestro gráfico de barras de proporción , necesitamos establecer group = 1. ¿Por qué? En otras palabras, ¿cuál es el problema con estos dos gráficos? ggplot(data = diamantes) + geom_bar(mapping = aes(x = corte, y = ..prop..)) ggplot(data = diamantes) + geom_bar(mapping = aes(x = corte, fill = color, y = ..prop..)) Solución Si no se incluye group = 1, todas las baras en el gráfico tendrán altura 1. La función geom_bar() asume que los grupos son iguales a los valores de x dado que el estadístico realiza un conteo dentro de los grupos. ggplot(data = diamantes) + geom_bar(mapping = aes(x = corte, y = ..prop..)) El problema con estos gráficos es que las proporciones se calculan dentro de los grupos. ggplot(data = diamantes) + geom_bar(mapping = aes(x = corte, y = ..prop..)) ggplot(data = diamantes) + geom_bar(mapping = aes(x = corte, fill = color, y = ..prop..)) El siguiente código generará el gráfico buscado sin relleno. ggplot(data = diamantes) + geom_bar(mapping = aes(x = corte, y = ..prop.., group = 1)) Con el argumento fill, es necesario normalizar las barras. ggplot(data = diamantes) + geom_bar(aes(x = corte, y = ..count.. / sum(..count..), fill = color)) 3.8 Ajustes de posición 3.8.1 Ejercicios ¿Cuál es el problema con este gráfico? ¿Cómo podrías mejorarlo? ggplot(data = millas, mapping = aes(x = ciudad, y = autopista)) + geom_point() Solución Existe superposición ya que hay múltiples observaciones para cada combinación de ciudad y autopista. Se puede mejorar el gráfico usando el argumento de distorsión y así reducir la superposición. ggplot(data = millas, mapping = aes(x = ciudad, y = autopista)) + geom_point(position = &quot;jitter&quot;) La relación entre ciudad y autopista es clara, incluso sin el argumento de distorsión, que en este caso deja en claro donde se concentran las observaciones. ¿Qué parámetros de geom_jitter() controlan la cantidad de ruido? Solución A partir de la documentación de geom_jitter(), existen dos argumentos: width controla el desplazamiento vertical height controla el desplazamiento horizontal Los valores por defecto de width y height introducen ruido en ambas direcciones. Así se ve el gráfico con las opciones por defecto. ggplot(data = millas, mapping = aes(x = ciudad, y = autopista)) + geom_point(position = position_jitter()) Con width = 0 se elimina la distorsión horizontal. ggplot(data = millas, mapping = aes(x = ciudad, y = autopista)) + geom_jitter(width = 0) Con width = 20 se agrega mucha distorsión. ggplot(data = millas, mapping = aes(x = ciudad, y = autopista)) + geom_jitter(width = 20) Es análogo para height. Hay que notar que width y height se expresan en las mismas unidades que los datos, por lo que height = 1 o width = 1 corresponden a diferentes valores relativos de distorsión dependiendo de las escalas de x e y. Los valores por defecto son 80% de la resolución (resolution()) de los datos. Cuando x e y son discretas, su resolución es igual a uno, y los valores por defecto son height = 0.4 y width = 0.4 ya que la distorsión mueve los puntos en dirección positiva y negativa. Compara y contrasta geom_jitter() con geom_count() Solución geom_jitter() agrega una variación al azar a los puntos del gráfico, es decir que distorsiona la ubicación de los puntos en el gráfico. Este método reduce la superposición ya que es poco probable que al mover los puntos al azar estos queden en la misma ubicación. Sin embargo, el problema de reducir la superposición es que se distorsionan los valores mostrados de x e y. ggplot(data = millas, mapping = aes(x = ciudad, y = autopista)) + geom_jitter() geom_count() cambia el tamaño de los puntos relativo a la cantidad de observaciones. Las combinaciones de x e y con más observaciones tendrán un mayor tamaño. Esto no distorsiona los valores, pero tiene el problema de que el tamaño de los puntos puede generar superposición si los puntos son cercanos. ggplot(data = millas, mapping = aes(x = ciudad, y = autopista)) + geom_count() Por ejemplo, geom_count() puede ser menos legible que geom_jitter() si se agrega un argumento de color. ggplot(data = millas, mapping = aes(x = ciudad, y = autopista, color = clase)) + geom_jitter() ggplot(data = millas, mapping = aes(x = ciudad, y = autopista, color = clase)) + geom_count() Este ejemplo muestra que no existe una solución universal. El coste y beneficio de cada enfoque depende de la estructura de los datos y del objetivo. ¿Cuál es el ajuste de posición predeterminado de geom_boxplot()? Crea una visualización del conjunto de datos de millas que lo demuestre. Solución La posición por defecto para geom_boxplot() es \"dodge2\", que es un atajo de position_dodge2. Este ajuste no cambia la posición vertical pero mueve las geometrías horizontalmente para evitar la superposición. Consulta la documentación de position_dodge2() para los detalles específicos. Si agregamos colour = clase a un diagrama de cajas, los niveles de transmision se ubican lado a lado. ggplot(data = millas, aes(x = transmision, y = autopista, colour = clase)) + geom_boxplot() Si se usa position_identity() habrá superposición. ggplot(data = millas, aes(x = transmision, y = autopista, colour = clase)) + geom_boxplot(position = &quot;identity&quot;) 3.9 Sistemas de coordenadas 3.9.1 Ejercicios Convierte un gráfico de barras apiladas en un gráfico circular usando coord_polar(). Solución Un gráfico de torta es un gráfico de barras aplicadas con la adición de coordenadas polares. Partamos del siguiente ejemplo: ggplot(millas, aes(x = factor(1), fill = traccion)) + geom_bar() Ahora agregamos coord_polar(theta=\"y\") para crear el gráfico de torta: ggplot(millas, aes(x = factor(1), fill = traccion)) + geom_bar(width = 1) + coord_polar(theta = &quot;y&quot;) El argumento theta = \"y\" transforma y en el ángulo de cada sección. Si coord_polar() se especifica sin theta = \"y\", el resultado se llama “ojo de buey”. ggplot(millas, aes(x = factor(1), fill = traccion)) + geom_bar(width = 1) + coord_polar() ¿Qué hace labs()? Lee la documentación. Solución labs agrega los títulos de los ejes, título del gráfico y la leyenda. ggplot(data = millas, mapping = aes(x = clase, y = autopista)) + geom_boxplot() + coord_flip() + labs(y = &quot;Millas por Galón en Autopista&quot;, x = &quot;Clase&quot;, title = &quot;Millas por Galón en Autopista por Tipo de Vehículo&quot;, subtitle = &quot;1999-2008&quot;, caption = &quot;Fuente: http://fueleconomy.gov&quot;) labs() no es la única función para agregar títulos. xlab(), ylab() y ggtitle() realizan la misma función. ¿Cuál es la diferencia entre coord_quickmap() y coord_map()? Solución coord_map() usa una proyección cartográfica para proyectar la Tierra sobre una superficie bidimensional. Por defecto usa la Proyección de Mercator, la cual se aplica a todas las geometrías del gráfico. coord_quickmap() usa una aproximación más rápida que ignora la curvatura de la tierra y ajusta de acuerdo a la razón de latitud y longitud. Esta es una alternativa computacionalmente más rápida que no genera la necesidad de transformar las geometrías individuales. Consulta coord_map() para la documentación y ejemplos. ¿Qué te dice la gráfica siguiente sobre la relación entre la ciudad y la autopista? ¿Por qué es coord_fixed() importante? ¿Qué hace geom_abline()? ggplot(data = millas, mapping = aes(x = ciudad, y = autopista)) + geom_point() + geom_abline() + coord_fixed() Solución La función coord_fixed() asegura que la línea que genera geom_abline() tenga un ángulo de 45 grados. De este modo es más fácil comparar a partir de los casos en que los rendimientos en autopista y ciudad son iguales. ggplot(data = millas, mapping = aes(x = ciudad, y = autopista)) + geom_point() + geom_abline() + coord_fixed() Lo que podemos ver es que en todos los modelos el rendimiento en autopista es superior al rendmiento en ciudad. "],["flujo-de-trabajo-conocimientos-básicos.html", "4 Flujo de trabajo: conocimientos básicos 4.4 Ejercicios", " 4 Flujo de trabajo: conocimientos básicos 4.4 Ejercicios ¿Por qué no funciona este código? mi_variable &lt;- 10 mi_varıable #&gt; Error in eval(expr, envir, enclos): object &#39;mi_varıable&#39; not found ¡Mira detenidamente! (Esto puede parecer un ejercicio inútil, pero entrenar tu cerebro para detectar incluso las diferencias más pequeñas será muy útil cuando comiences a programar.) Solución En la segunda línea de código la letra “i” no tiene punto. Si bien a primera vista se ven similares, al mirar detenidamente podemos ver que mi_variable no es igual a mi_variable Modifica cada una de las instrucciones de R a continuación para que puedan ejecutarse correctamente: library(tidyverse) library(datos) ggplot(dota = millas) + geom_point(mapping = aes(x = motor, y = autopista)) fliter(millas, cilindros = 8) filter(diamante, quilate &gt; 3) Solución En los tres casos hay problemas de tipeo. En el primero, dice dota = millas y debería decir data = millas: ```r ggplot(data = millas) + geom_point(mapping = aes(x = motor, y = autopista)) ``` En el segundo, hay un problema en la forma en que se escribió el nombre de la función. Dice fliter en vez de filter: ```r filter(millas, cilindros = 8) ``` En el tercero, es necesario corregir la forma en que se escribió el nombre del conjunto de datos. Debiese estar en plural, es decir, diamantes. ```r filter(diamantes, quilate &gt; 3) ``` Presiona Alt + Shift + K. ¿Qué ocurrió? ¿Cómo puedes llegar al mismo lugar utilizando los menús? Solución Alt + Shift + K es el comando abreviado o shortcut para ver la lista de comandos abreviados de RStudio. Al presionarlo se abre una nueva ventana con todos los comandos disponibles. Para llegar a esa misma lista utilizando los menús, tienes que ir a Tools &gt; Keyboard Shortcuts Help. "],["transform.html", "5 Transformación de datos 5.1 Introducción 5.2 Filtrar filas con filter() 5.3 Reordenar las filas con arrange() 5.4 Seleccionar columnas con select() 5.5 Añadir nuevas variables con mutate() 5.6 Resúmenes agrupados con summarise() 5.7 Transformaciones agrupadas (y filtros)", " 5 Transformación de datos 5.1 Introducción library(tidyverse) library(datos) 5.2 Filtrar filas con filter() 5.2.4 Ejercicios Encuentra todos los vuelos que: Tuvieron un retraso de llegada de dos o más horas Solución filter(vuelos, atraso_llegada &gt;= 120) #&gt; # A tibble: 10,200 × 19 #&gt; anio mes dia horario_salida salida_programada atraso_salida #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 2013 1 1 811 630 101 #&gt; 2 2013 1 1 848 1835 853 #&gt; 3 2013 1 1 957 733 144 #&gt; 4 2013 1 1 1114 900 134 #&gt; 5 2013 1 1 1505 1310 115 #&gt; 6 2013 1 1 1525 1340 105 #&gt; # … with 10,194 more rows, and 13 more variables: horario_llegada &lt;int&gt;, #&gt; # llegada_programada &lt;int&gt;, atraso_llegada &lt;dbl&gt;, aerolinea &lt;chr&gt;, #&gt; # vuelo &lt;int&gt;, codigo_cola &lt;chr&gt;, origen &lt;chr&gt;, destino &lt;chr&gt;, #&gt; # tiempo_vuelo &lt;dbl&gt;, distancia &lt;dbl&gt;, hora &lt;dbl&gt;, minuto &lt;dbl&gt;, #&gt; # fecha_hora &lt;dttm&gt; Volaron a Houston (IAH oHOU) Solución #Opcion 1 filter(vuelos, destino %in% c(&quot;IAH&quot;, &quot;HOU&quot;)) #&gt; # A tibble: 9,313 × 19 #&gt; anio mes dia horario_salida salida_programada atraso_salida #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 2013 1 1 517 515 2 #&gt; 2 2013 1 1 533 529 4 #&gt; 3 2013 1 1 623 627 -4 #&gt; 4 2013 1 1 728 732 -4 #&gt; 5 2013 1 1 739 739 0 #&gt; 6 2013 1 1 908 908 0 #&gt; # … with 9,307 more rows, and 13 more variables: horario_llegada &lt;int&gt;, #&gt; # llegada_programada &lt;int&gt;, atraso_llegada &lt;dbl&gt;, aerolinea &lt;chr&gt;, #&gt; # vuelo &lt;int&gt;, codigo_cola &lt;chr&gt;, origen &lt;chr&gt;, destino &lt;chr&gt;, #&gt; # tiempo_vuelo &lt;dbl&gt;, distancia &lt;dbl&gt;, hora &lt;dbl&gt;, minuto &lt;dbl&gt;, #&gt; # fecha_hora &lt;dttm&gt; #Opción 2 filter(vuelos,destino == &quot;IAH&quot; | destino == &quot;HOU&quot; ) #&gt; # A tibble: 9,313 × 19 #&gt; anio mes dia horario_salida salida_programada atraso_salida #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 2013 1 1 517 515 2 #&gt; 2 2013 1 1 533 529 4 #&gt; 3 2013 1 1 623 627 -4 #&gt; 4 2013 1 1 728 732 -4 #&gt; 5 2013 1 1 739 739 0 #&gt; 6 2013 1 1 908 908 0 #&gt; # … with 9,307 more rows, and 13 more variables: horario_llegada &lt;int&gt;, #&gt; # llegada_programada &lt;int&gt;, atraso_llegada &lt;dbl&gt;, aerolinea &lt;chr&gt;, #&gt; # vuelo &lt;int&gt;, codigo_cola &lt;chr&gt;, origen &lt;chr&gt;, destino &lt;chr&gt;, #&gt; # tiempo_vuelo &lt;dbl&gt;, distancia &lt;dbl&gt;, hora &lt;dbl&gt;, minuto &lt;dbl&gt;, #&gt; # fecha_hora &lt;dttm&gt; Fueron operados por United, American o Delta Solución Los códigos de estas aerolíneas son UA, AA y DL. filter(vuelos, aerolinea %in% c(&quot;UA&quot;, &quot;AA&quot;, &quot;DL&quot;)) #&gt; # A tibble: 139,504 × 19 #&gt; anio mes dia horario_salida salida_programada atraso_salida #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 2013 1 1 517 515 2 #&gt; 2 2013 1 1 533 529 4 #&gt; 3 2013 1 1 542 540 2 #&gt; 4 2013 1 1 554 600 -6 #&gt; 5 2013 1 1 554 558 -4 #&gt; 6 2013 1 1 558 600 -2 #&gt; # … with 139,498 more rows, and 13 more variables: horario_llegada &lt;int&gt;, #&gt; # llegada_programada &lt;int&gt;, atraso_llegada &lt;dbl&gt;, aerolinea &lt;chr&gt;, #&gt; # vuelo &lt;int&gt;, codigo_cola &lt;chr&gt;, origen &lt;chr&gt;, destino &lt;chr&gt;, #&gt; # tiempo_vuelo &lt;dbl&gt;, distancia &lt;dbl&gt;, hora &lt;dbl&gt;, minuto &lt;dbl&gt;, #&gt; # fecha_hora &lt;dttm&gt; Partieron en el invierno del hemisferio sur (julio, agosto y septiembre) Solución filter(vuelos, mes %in% c(7, 8, 9)) #&gt; # A tibble: 86,326 × 19 #&gt; anio mes dia horario_salida salida_programada atraso_salida #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 2013 7 1 1 2029 212 #&gt; 2 2013 7 1 2 2359 3 #&gt; 3 2013 7 1 29 2245 104 #&gt; 4 2013 7 1 43 2130 193 #&gt; 5 2013 7 1 44 2150 174 #&gt; 6 2013 7 1 46 2051 235 #&gt; # … with 86,320 more rows, and 13 more variables: horario_llegada &lt;int&gt;, #&gt; # llegada_programada &lt;int&gt;, atraso_llegada &lt;dbl&gt;, aerolinea &lt;chr&gt;, #&gt; # vuelo &lt;int&gt;, codigo_cola &lt;chr&gt;, origen &lt;chr&gt;, destino &lt;chr&gt;, #&gt; # tiempo_vuelo &lt;dbl&gt;, distancia &lt;dbl&gt;, hora &lt;dbl&gt;, minuto &lt;dbl&gt;, #&gt; # fecha_hora &lt;dttm&gt; Llegaron más de dos horas tarde, pero no salieron tarde Solución filter(vuelos, atraso_salida &lt;= 0 &amp; atraso_llegada &gt; 120) #&gt; # A tibble: 29 × 19 #&gt; anio mes dia horario_salida salida_programada atraso_salida #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 2013 1 27 1419 1420 -1 #&gt; 2 2013 10 7 1350 1350 0 #&gt; 3 2013 10 7 1357 1359 -2 #&gt; 4 2013 10 16 657 700 -3 #&gt; 5 2013 11 1 658 700 -2 #&gt; 6 2013 3 18 1844 1847 -3 #&gt; # … with 23 more rows, and 13 more variables: horario_llegada &lt;int&gt;, #&gt; # llegada_programada &lt;int&gt;, atraso_llegada &lt;dbl&gt;, aerolinea &lt;chr&gt;, #&gt; # vuelo &lt;int&gt;, codigo_cola &lt;chr&gt;, origen &lt;chr&gt;, destino &lt;chr&gt;, #&gt; # tiempo_vuelo &lt;dbl&gt;, distancia &lt;dbl&gt;, hora &lt;dbl&gt;, minuto &lt;dbl&gt;, #&gt; # fecha_hora &lt;dttm&gt; Se retrasaron por lo menos una hora, pero repusieron más de 30 minutos en vuelo Solución filter(vuelos, atraso_salida &gt;= 60 &amp; atraso_salida - atraso_llegada &gt; 30) #&gt; # A tibble: 1,844 × 19 #&gt; anio mes dia horario_salida salida_programada atraso_salida #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 2013 1 1 2205 1720 285 #&gt; 2 2013 1 1 2326 2130 116 #&gt; 3 2013 1 3 1503 1221 162 #&gt; 4 2013 1 3 1839 1700 99 #&gt; 5 2013 1 3 1850 1745 65 #&gt; 6 2013 1 3 1941 1759 102 #&gt; # … with 1,838 more rows, and 13 more variables: horario_llegada &lt;int&gt;, #&gt; # llegada_programada &lt;int&gt;, atraso_llegada &lt;dbl&gt;, aerolinea &lt;chr&gt;, #&gt; # vuelo &lt;int&gt;, codigo_cola &lt;chr&gt;, origen &lt;chr&gt;, destino &lt;chr&gt;, #&gt; # tiempo_vuelo &lt;dbl&gt;, distancia &lt;dbl&gt;, hora &lt;dbl&gt;, minuto &lt;dbl&gt;, #&gt; # fecha_hora &lt;dttm&gt; Partieron entre la medianoche y las 6 a.m. (incluyente) Solución filter(vuelos,horario_salida %in% c(1:600) | horario_salida == 2400 ) #&gt; # A tibble: 9,373 × 19 #&gt; anio mes dia horario_salida salida_programada atraso_salida #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 2013 1 1 517 515 2 #&gt; 2 2013 1 1 533 529 4 #&gt; 3 2013 1 1 542 540 2 #&gt; 4 2013 1 1 544 545 -1 #&gt; 5 2013 1 1 554 600 -6 #&gt; 6 2013 1 1 554 558 -4 #&gt; # … with 9,367 more rows, and 13 more variables: horario_llegada &lt;int&gt;, #&gt; # llegada_programada &lt;int&gt;, atraso_llegada &lt;dbl&gt;, aerolinea &lt;chr&gt;, #&gt; # vuelo &lt;int&gt;, codigo_cola &lt;chr&gt;, origen &lt;chr&gt;, destino &lt;chr&gt;, #&gt; # tiempo_vuelo &lt;dbl&gt;, distancia &lt;dbl&gt;, hora &lt;dbl&gt;, minuto &lt;dbl&gt;, #&gt; # fecha_hora &lt;dttm&gt; Otra función de dplyr útil para usar filtros es between(). ¿Qué hace? ¿Puedes usarlo para simplificar el código necesario para responder a los desafíos anteriores? Solución Esta función del paquete dplyr permite abreviar la escritura de código que tiene esta estructura x &gt;= derecha &amp; x &lt;= izquierda por between(x, derecha, izquierda). Podemos reescribir el código para encontrar los vuelos que partieron en el invierno del hemisferio sur así: filter(vuelos, between(mes, 7, 9)) #&gt; # A tibble: 86,326 × 19 #&gt; anio mes dia horario_salida salida_programada atraso_salida #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 2013 7 1 1 2029 212 #&gt; 2 2013 7 1 2 2359 3 #&gt; 3 2013 7 1 29 2245 104 #&gt; 4 2013 7 1 43 2130 193 #&gt; 5 2013 7 1 44 2150 174 #&gt; 6 2013 7 1 46 2051 235 #&gt; # … with 86,320 more rows, and 13 more variables: horario_llegada &lt;int&gt;, #&gt; # llegada_programada &lt;int&gt;, atraso_llegada &lt;dbl&gt;, aerolinea &lt;chr&gt;, #&gt; # vuelo &lt;int&gt;, codigo_cola &lt;chr&gt;, origen &lt;chr&gt;, destino &lt;chr&gt;, #&gt; # tiempo_vuelo &lt;dbl&gt;, distancia &lt;dbl&gt;, hora &lt;dbl&gt;, minuto &lt;dbl&gt;, #&gt; # fecha_hora &lt;dttm&gt; ¿Cuántos vuelos tienen datos faltantes de horario_salida? ¿Qué otras variables tienen valores faltantes? ¿Qué representan estas filas? Solución Podemos buscar datos faltantes con la función is.na. filter(vuelos, is.na(horario_salida)) #&gt; # A tibble: 8,255 × 19 #&gt; anio mes dia horario_salida salida_programada atraso_salida #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 2013 1 1 NA 1630 NA #&gt; 2 2013 1 1 NA 1935 NA #&gt; 3 2013 1 1 NA 1500 NA #&gt; 4 2013 1 1 NA 600 NA #&gt; 5 2013 1 2 NA 1540 NA #&gt; 6 2013 1 2 NA 1620 NA #&gt; # … with 8,249 more rows, and 13 more variables: horario_llegada &lt;int&gt;, #&gt; # llegada_programada &lt;int&gt;, atraso_llegada &lt;dbl&gt;, aerolinea &lt;chr&gt;, #&gt; # vuelo &lt;int&gt;, codigo_cola &lt;chr&gt;, origen &lt;chr&gt;, destino &lt;chr&gt;, #&gt; # tiempo_vuelo &lt;dbl&gt;, distancia &lt;dbl&gt;, hora &lt;dbl&gt;, minuto &lt;dbl&gt;, #&gt; # fecha_hora &lt;dttm&gt; Los vuelos que tienen NA en su horario de salida, también lo tienen en el horario de llegada, por lo que se puede inferir que son vuelos que fueron cancelados. ¿Por qué NA ^ 0 no es faltante? ¿Por qué NA | TRUE no es faltante? ¿Por qué FALSE &amp; NA no es faltante? ¿Puedes descubrir la regla general? (¡NA * 0 es un contraejemplo complicado!) Solución x &lt;- c(NA) is.na(x) #&gt; [1] TRUE La función is.na() determina si falta un valor y devuelve un valor lógico TRUE en los casos en que es NA (Not Available). x^0 #&gt; [1] 1 Dado que el NA podría tomar cualquier valor, es práctico pensar que cualquier número (aunque sea muy grande) a la potencia cero es igual a 1. x | TRUE #&gt; [1] TRUE Es igual a TRUE pues el NA se entiende como un valor lógico (TRUE or FALSE) y por lógica proposicional TRUE | TRUE y FALSE | TRUE es siempre igual a TRUE. x &amp; FALSE #&gt; [1] FALSE Es igual a TRUE pues el NA se entiende como un valor lógico (TRUE or FALSE) y por lógica proposicional TRUE&amp;FALSE y FALSE&amp;FALSE es siempre FALSE. El contraejemplo a la regla general: x * 0 #&gt; [1] NA Inf*0 #&gt; [1] NaN En este contraejemplo puede ser útil pensar que el NA puede tomar cualquier valor, incluso podría ser un número muy grande; el cual al multiplicarse por cero nos da una indeterminación que R define como NaN (Not a Number). Por otro lado, si el NA fuese un valor pequeño, entonces NA*0 sería igual a cero. Luego, es mejor pensar en x*0 como un NA porque no sabemos en cual de los dos casos anteriores estamos. 5.3 Reordenar las filas con arrange() 5.3.1 Ejercicios ¿Cómo podrías usar arrange() para ordenar todos los valores faltantes al comienzo? (Sugerencia: usa is.na()). Solución arrange(vuelos,desc(is.na(tiempo_vuelo))) #&gt; # A tibble: 336,776 × 19 #&gt; anio mes dia horario_salida salida_programada atraso_salida #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 2013 1 1 1525 1530 -5 #&gt; 2 2013 1 1 1528 1459 29 #&gt; 3 2013 1 1 1740 1745 -5 #&gt; 4 2013 1 1 1807 1738 29 #&gt; 5 2013 1 1 1939 1840 59 #&gt; 6 2013 1 1 1952 1930 22 #&gt; # … with 336,770 more rows, and 13 more variables: horario_llegada &lt;int&gt;, #&gt; # llegada_programada &lt;int&gt;, atraso_llegada &lt;dbl&gt;, aerolinea &lt;chr&gt;, #&gt; # vuelo &lt;int&gt;, codigo_cola &lt;chr&gt;, origen &lt;chr&gt;, destino &lt;chr&gt;, #&gt; # tiempo_vuelo &lt;dbl&gt;, distancia &lt;dbl&gt;, hora &lt;dbl&gt;, minuto &lt;dbl&gt;, #&gt; # fecha_hora &lt;dttm&gt; Se usa la variable tiempo_vuelo porque es la que contiene mayor número de NA´s. Ordena vuelos para encontrar los vuelos más retrasados. Encuentra los vuelos que salieron más temprano. Solución Vuelos que salieron con más retraso arrange(vuelos, desc(atraso_salida)) #&gt; # A tibble: 336,776 × 19 #&gt; anio mes dia horario_salida salida_programada atraso_salida #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 2013 1 9 641 900 1301 #&gt; 2 2013 6 15 1432 1935 1137 #&gt; 3 2013 1 10 1121 1635 1126 #&gt; 4 2013 9 20 1139 1845 1014 #&gt; 5 2013 7 22 845 1600 1005 #&gt; 6 2013 4 10 1100 1900 960 #&gt; # … with 336,770 more rows, and 13 more variables: horario_llegada &lt;int&gt;, #&gt; # llegada_programada &lt;int&gt;, atraso_llegada &lt;dbl&gt;, aerolinea &lt;chr&gt;, #&gt; # vuelo &lt;int&gt;, codigo_cola &lt;chr&gt;, origen &lt;chr&gt;, destino &lt;chr&gt;, #&gt; # tiempo_vuelo &lt;dbl&gt;, distancia &lt;dbl&gt;, hora &lt;dbl&gt;, minuto &lt;dbl&gt;, #&gt; # fecha_hora &lt;dttm&gt; Vuelos que salieron más temprano arrange(vuelos, atraso_salida) #&gt; # A tibble: 336,776 × 19 #&gt; anio mes dia horario_salida salida_programada atraso_salida #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 2013 12 7 2040 2123 -43 #&gt; 2 2013 2 3 2022 2055 -33 #&gt; 3 2013 11 10 1408 1440 -32 #&gt; 4 2013 1 11 1900 1930 -30 #&gt; 5 2013 1 29 1703 1730 -27 #&gt; 6 2013 8 9 729 755 -26 #&gt; # … with 336,770 more rows, and 13 more variables: horario_llegada &lt;int&gt;, #&gt; # llegada_programada &lt;int&gt;, atraso_llegada &lt;dbl&gt;, aerolinea &lt;chr&gt;, #&gt; # vuelo &lt;int&gt;, codigo_cola &lt;chr&gt;, origen &lt;chr&gt;, destino &lt;chr&gt;, #&gt; # tiempo_vuelo &lt;dbl&gt;, distancia &lt;dbl&gt;, hora &lt;dbl&gt;, minuto &lt;dbl&gt;, #&gt; # fecha_hora &lt;dttm&gt; Ordena vuelos para encontrar los vuelos más rápidos. Solución Si se considera que la velocidad es igual a distancia/tiempo_vuelo (distancia recorrida por minuto). Los datos ordenados de forma descendente nos dará como resultado los vuelos más rápidos primero. arrange(vuelos,desc(distancia/tiempo_vuelo)) #&gt; # A tibble: 336,776 × 19 #&gt; anio mes dia horario_salida salida_programada atraso_salida #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 2013 5 25 1709 1700 9 #&gt; 2 2013 7 2 1558 1513 45 #&gt; 3 2013 5 13 2040 2025 15 #&gt; 4 2013 3 23 1914 1910 4 #&gt; 5 2013 1 12 1559 1600 -1 #&gt; 6 2013 11 17 650 655 -5 #&gt; # … with 336,770 more rows, and 13 more variables: horario_llegada &lt;int&gt;, #&gt; # llegada_programada &lt;int&gt;, atraso_llegada &lt;dbl&gt;, aerolinea &lt;chr&gt;, #&gt; # vuelo &lt;int&gt;, codigo_cola &lt;chr&gt;, origen &lt;chr&gt;, destino &lt;chr&gt;, #&gt; # tiempo_vuelo &lt;dbl&gt;, distancia &lt;dbl&gt;, hora &lt;dbl&gt;, minuto &lt;dbl&gt;, #&gt; # fecha_hora &lt;dttm&gt; ¿Cuáles vuelos viajaron más lejos? ¿Cuál viajó menos cerca? Solución Vuelos que viajaron más lejos (considerando la distancia en millas entre aeropuertos): arrange(vuelos,desc(distancia)) #&gt; # A tibble: 336,776 × 19 #&gt; anio mes dia horario_salida salida_programada atraso_salida #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 2013 1 1 857 900 -3 #&gt; 2 2013 1 2 909 900 9 #&gt; 3 2013 1 3 914 900 14 #&gt; 4 2013 1 4 900 900 0 #&gt; 5 2013 1 5 858 900 -2 #&gt; 6 2013 1 6 1019 900 79 #&gt; # … with 336,770 more rows, and 13 more variables: horario_llegada &lt;int&gt;, #&gt; # llegada_programada &lt;int&gt;, atraso_llegada &lt;dbl&gt;, aerolinea &lt;chr&gt;, #&gt; # vuelo &lt;int&gt;, codigo_cola &lt;chr&gt;, origen &lt;chr&gt;, destino &lt;chr&gt;, #&gt; # tiempo_vuelo &lt;dbl&gt;, distancia &lt;dbl&gt;, hora &lt;dbl&gt;, minuto &lt;dbl&gt;, #&gt; # fecha_hora &lt;dttm&gt; Vuelos que viajaron más cerca (considerando la distancia en millas entre aeropuertos): arrange(vuelos,distancia) #&gt; # A tibble: 336,776 × 19 #&gt; anio mes dia horario_salida salida_programada atraso_salida #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 2013 7 27 NA 106 NA #&gt; 2 2013 1 3 2127 2129 -2 #&gt; 3 2013 1 4 1240 1200 40 #&gt; 4 2013 1 4 1829 1615 134 #&gt; 5 2013 1 4 2128 2129 -1 #&gt; 6 2013 1 5 1155 1200 -5 #&gt; # … with 336,770 more rows, and 13 more variables: horario_llegada &lt;int&gt;, #&gt; # llegada_programada &lt;int&gt;, atraso_llegada &lt;dbl&gt;, aerolinea &lt;chr&gt;, #&gt; # vuelo &lt;int&gt;, codigo_cola &lt;chr&gt;, origen &lt;chr&gt;, destino &lt;chr&gt;, #&gt; # tiempo_vuelo &lt;dbl&gt;, distancia &lt;dbl&gt;, hora &lt;dbl&gt;, minuto &lt;dbl&gt;, #&gt; # fecha_hora &lt;dttm&gt; 5.4 Seleccionar columnas con select() 5.4.1 Ejercicios Haz una lluvia de ideas de tantas maneras como sea posible para seleccionar horario_salida,atraso_salida,horario_llegada, yatraso_llegada de vuelos. Solución Una primera opción sería seleccionaras por su nombre: select(vuelos, horario_salida, atraso_salida, horario_llegada, atraso_llegada) #&gt; # A tibble: 336,776 × 4 #&gt; horario_salida atraso_salida horario_llegada atraso_llegada #&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 517 2 830 11 #&gt; 2 533 4 850 20 #&gt; 3 542 2 923 33 #&gt; 4 544 -1 1004 -18 #&gt; 5 554 -6 812 -25 #&gt; 6 554 -4 740 12 #&gt; # … with 336,770 more rows Otra forma es seleccionando las variables que empiezan con “horario” y “atraso” con la función starts_with() (“empieza con”) del paquete dplyr: select(vuelos, starts_with(&quot;horario&quot;), starts_with(&quot;atraso&quot;)) #&gt; # A tibble: 336,776 × 4 #&gt; horario_salida horario_llegada atraso_salida atraso_llegada #&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 517 830 2 11 #&gt; 2 533 850 4 20 #&gt; 3 542 923 2 33 #&gt; 4 544 1004 -1 -18 #&gt; 5 554 812 -6 -25 #&gt; 6 554 740 -4 12 #&gt; # … with 336,770 more rows También es útil en este caso utilizar la función ends_with(): select(vuelos,ends_with(&quot;llegada&quot;),ends_with(&quot;salida&quot;)) #&gt; # A tibble: 336,776 × 4 #&gt; horario_llegada atraso_llegada horario_salida atraso_salida #&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 830 11 517 2 #&gt; 2 850 20 533 4 #&gt; 3 923 33 542 2 #&gt; 4 1004 -18 544 -1 #&gt; 5 812 -25 554 -6 #&gt; 6 740 12 554 -4 #&gt; # … with 336,770 more rows Y una manera adicional es usando la función contains(): select(vuelos,contains(&quot;horario&quot;),contains(&quot;atraso&quot;)) #&gt; # A tibble: 336,776 × 4 #&gt; horario_salida horario_llegada atraso_salida atraso_llegada #&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 517 830 2 11 #&gt; 2 533 850 4 20 #&gt; 3 542 923 2 33 #&gt; 4 544 1004 -1 -18 #&gt; 5 554 812 -6 -25 #&gt; 6 554 740 -4 12 #&gt; # … with 336,770 more rows ¿Qué sucede si incluyes el nombre de una variable varias veces en una llamada select()? Solución A diferencia de lo que podría pensarse inicialmente, aunque se incluya más de una vez una variable al utilizar select() esta solo se considerará una vez: select(vuelos, horario_salida, horario_salida, horario_salida) #&gt; # A tibble: 336,776 × 1 #&gt; horario_salida #&gt; &lt;int&gt; #&gt; 1 517 #&gt; 2 533 #&gt; 3 542 #&gt; 4 544 #&gt; 5 554 #&gt; 6 554 #&gt; # … with 336,770 more rows ¿Qué hace la función one_of()? ¿Por qué podría ser útil en conjunto con este vector? vars &lt;- c (&quot;anio&quot;, &quot;mes&quot;, &quot;dia&quot;, &quot;atraso_salida&quot;, &quot;atraso_llegada&quot;) Solución Con la función one_of() podemos indicar las variables que queremos seleccionar con el nombre del vector que las contiene. La función one_of() selecciona todas las variables que están en el vector vars: select(vuelos, one_of(vars)) #&gt; # A tibble: 336,776 × 5 #&gt; anio mes dia atraso_salida atraso_llegada #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 2013 1 1 2 11 #&gt; 2 2013 1 1 4 20 #&gt; 3 2013 1 1 2 33 #&gt; 4 2013 1 1 -1 -18 #&gt; 5 2013 1 1 -6 -25 #&gt; 6 2013 1 1 -4 12 #&gt; # … with 336,770 more rows Sin embargo, es posible también hacerlo de la siguiente forma (Siempre y cuando no exista una variable que se llame vars en el set de datos): select(vuelos,vars) #&gt; Note: Using an external vector in selections is ambiguous. #&gt; ℹ Use `all_of(vars)` instead of `vars` to silence this message. #&gt; ℹ See &lt;https://tidyselect.r-lib.org/reference/faq-external-vector.html&gt;. #&gt; This message is displayed once per session. #&gt; # A tibble: 336,776 × 5 #&gt; anio mes dia atraso_salida atraso_llegada #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 2013 1 1 2 11 #&gt; 2 2013 1 1 4 20 #&gt; 3 2013 1 1 2 33 #&gt; 4 2013 1 1 -1 -18 #&gt; 5 2013 1 1 -6 -25 #&gt; 6 2013 1 1 -4 12 #&gt; # … with 336,770 more rows ¿Te sorprende el resultado de ejecutar el siguiente código? ¿Cómo tratan por defecto las funciones auxiliares de select() a las palabras en mayúsculas o en minúsculas? ¿Cómo puedes cambiar ese comportamiento predeterminado? select(vuelos, contains(&quot;SALIDA&quot;)) Solución La función contains() (“contiene”) no distingue entre mayúsculas y minúsculas, por eso puede identificar sin problema todas las variables que contienen “salida”. Si queremos cambiar este comportamiento y que sí las diferencie, entonces debemos agregar el argumento ignore.case = FALSE (por defecto, es TRUE): select(vuelos, contains(&quot;SALIDA&quot;, ignore.case = FALSE)) #&gt; # A tibble: 336,776 × 0 5.5 Añadir nuevas variables con mutate() 5.5.2 Ejercicios Las variables horario_salida y salida_programada tienen un formato conveniente para leer, pero es difícil realizar cualquier cálculo con ellas porque no son realmente números continuos. Transfórmalas a un formato más conveniente, como número de minutos desde la medianoche. Solución Los datos de estas variables son de tal forma que las 6:59 AM toman el valor 659. Luego, el número de horas desde la media noche es: 659%/%100 #division entera #&gt; [1] 6 La cantidad de minutos en esas 6 horas: 659%/%100 *60 #&gt; [1] 360 Solo queda sumar los 59 minutos: 659 %% 100 #resto #&gt; [1] 59 Entonces, el número de minutos transcurridos desde las 00:00 hasta las 6:59 AM son: 659 %/% 100 * 60 + 659 %% 100 #&gt; [1] 419 Sin embargo, la medianoche toma el valor 24:00 con lo cual el número de minutos desde la medianoche es 1440 en lugar de 0. Para resolver esto usamos nuevamente %%. (659 %/% 100 * 60 + 659 %% 100) %% 1440 #mismo resultado anterior #&gt; [1] 419 (2400 %/% 100 * 60 + 2400 %% 100) %% 1440 #cero minutos desde la medianoche #&gt; [1] 0 mutate(vuelos, salida_programada_min = (salida_programada %/% 100 * 60 + salida_programada %% 100) %% 1440) #&gt; # A tibble: 336,776 × 20 #&gt; anio mes dia horario_salida salida_programada atraso_salida #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 2013 1 1 517 515 2 #&gt; 2 2013 1 1 533 529 4 #&gt; 3 2013 1 1 542 540 2 #&gt; 4 2013 1 1 544 545 -1 #&gt; 5 2013 1 1 554 600 -6 #&gt; 6 2013 1 1 554 558 -4 #&gt; # … with 336,770 more rows, and 14 more variables: horario_llegada &lt;int&gt;, #&gt; # llegada_programada &lt;int&gt;, atraso_llegada &lt;dbl&gt;, aerolinea &lt;chr&gt;, #&gt; # vuelo &lt;int&gt;, codigo_cola &lt;chr&gt;, origen &lt;chr&gt;, destino &lt;chr&gt;, #&gt; # tiempo_vuelo &lt;dbl&gt;, distancia &lt;dbl&gt;, hora &lt;dbl&gt;, minuto &lt;dbl&gt;, #&gt; # fecha_hora &lt;dttm&gt;, salida_programada_min &lt;dbl&gt; mutate(vuelos, horario_salida_min = (horario_salida %/% 100 * 60 + horario_salida %% 100) %% 1440) #&gt; # A tibble: 336,776 × 20 #&gt; anio mes dia horario_salida salida_programada atraso_salida #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 2013 1 1 517 515 2 #&gt; 2 2013 1 1 533 529 4 #&gt; 3 2013 1 1 542 540 2 #&gt; 4 2013 1 1 544 545 -1 #&gt; 5 2013 1 1 554 600 -6 #&gt; 6 2013 1 1 554 558 -4 #&gt; # … with 336,770 more rows, and 14 more variables: horario_llegada &lt;int&gt;, #&gt; # llegada_programada &lt;int&gt;, atraso_llegada &lt;dbl&gt;, aerolinea &lt;chr&gt;, #&gt; # vuelo &lt;int&gt;, codigo_cola &lt;chr&gt;, origen &lt;chr&gt;, destino &lt;chr&gt;, #&gt; # tiempo_vuelo &lt;dbl&gt;, distancia &lt;dbl&gt;, hora &lt;dbl&gt;, minuto &lt;dbl&gt;, #&gt; # fecha_hora &lt;dttm&gt;, horario_salida_min &lt;dbl&gt; Compara tiempo_vuelo con horario_llegada - horario_salida. ¿Qué esperas ver? ¿Qué ves? ¿Qué necesitas hacer para arreglarlo? Solución Lo que se espera es que tiempo_vuelo = horario_llegada - horario_salida. Compara horario_salida, salida_programada, y atraso_salida. ¿Cómo esperarías que esos tres números estén relacionados? Solución Encuentra los 10 vuelos más retrasados utilizando una función de ordenamiento. ¿Cómo quieres manejar los empates? Lee atentamente la documentación de min_rank(). Solución ¿Qué devuelve 1:3 + 1:10? ¿Por qué? Solución ¿Qué funciones trigonométricas proporciona R? Solución 5.6 Resúmenes agrupados con summarise() 5.6.7 Ejercicios Haz una lluvia de ideas de al menos 5 formas diferentes de evaluar las características de un retraso típico de un grupo de vuelos. Considera los siguientes escenarios: *Un vuelo llega 15 minutos antes 50% del tiempo, y 15 minutos tarde 50% del tiempo. *Un vuelo llega siempre 10 minutos tarde. *Un vuelo llega 30 minutos antes 50% del tiempo, y 30 minutos tarde 50% del tiempo. *Un vuelo llega a tiempo en el 99% de los casos. 1% de las veces llega 2 horas tarde. ¿Qué es más importante: retraso de la llegada o demora de salida? Solución Sugiere un nuevo enfoque que te dé el mismo output que no_cancelados %&gt;% count(destino) y no_cancelado %&gt;% count(codigo_cola, wt = distancia) (sin usar count()). Solución Nuestra definición de vuelos cancelados (is.na(atraso_salida) | is.na (atraso_llegada)) es un poco subóptima. ¿Por qué? ¿Cuál es la columna más importante? Solución Mira la cantidad de vuelos cancelados por día. ¿Hay un patrón? ¿La proporción de vuelos cancelados está relacionada con el retraso promedio? Solución ¿Qué compañía tiene los peores retrasos? Desafío: ¿puedes desenredar el efecto de malos aeropuertos vs. el efecto de malas aerolíneas? ¿Por qué o por qué no? (Sugerencia: piensa en vuelos %&gt;% group_by(aerolinea, destino) %&gt;% summarise(n())) Solución ¿Qué hace el argumento sort a count(). ¿Cuándo podrías usarlo? Solución 5.7 Transformaciones agrupadas (y filtros) 5.7.1 Ejercicios Remítete a las listas de funciones útiles de mutación y filtrado. Describe cómo cambia cada operación cuando las combinas con la agrupación. Solución ¿Qué avión (codigo_cola) tiene el peor registro de tiempo? Solución ¿A qué hora del día deberías volar si quieres evitar los retrasos lo más posible? Solución Para cada destino, calcula los minutos totales de demora. Para cada vuelo, calcula la proporción de la demora total para su destino. Solución Los retrasos suelen estar temporalmente correlacionados: incluso una vez que el problema que causó el retraso inicial se ha resuelto, los vuelos posteriores se retrasan para permitir que salgan los vuelos anteriores. Usando lag(), explora cómo el retraso de un vuelo está relacionado con el retraso del vuelo inmediatamente anterior. Solución Mira cada destino. ¿Puedes encontrar vuelos sospechosamente rápidos? (es decir, vuelos que representan un posible error de entrada de datos). Calcula el tiempo en el aire de un vuelo relativo al vuelo más corto a ese destino. ¿Cuáles vuelos se retrasaron más en el aire? Solución Encuentra todos los destinos que son volados por al menos dos operadores. Usa esta información para clasificar a las aerolíneas. Solución Para cada avión, cuenta el número de vuelos antes del primer retraso de más de 1 hora. Solución "],["flujo-de-trabajo-scripts.html", "6 Flujo de trabajo: Scripts 6.3 Ejercicios", " 6 Flujo de trabajo: Scripts 6.3 Ejercicios Visita la cuenta de Twitter de RStudio Tips, https://twitter.com/rstudiotips, y encuentra algún tip que parezca interesante. Practica utilizándolo. ¿Qué otros errores comunes reportarán los diagnósticos de RStudio? Lee https://support.rstudio.com/hc/en-us/articles/205753617-Code-Diagnostics para descubrirlo. "],["análisis-exploratorio-de-datos-eda.html", "7 Análisis exploratorio de datos (EDA) 7.1 Introducción 7.3 Variación 7.4 Valores faltantes 7.5 Covariación 7.5.2 Dos variables categóricas 7.5.3 Dos variables continuas", " 7 Análisis exploratorio de datos (EDA) 7.1 Introducción library(tidyverse) library(datos) 7.3 Variación 7.3.4 Ejercicios Explora la distribución de cada una de las variables x, y, y z en el set de datos diamantes. ¿Qué aprendiste? Piensa en un diamante y cómo decidirías qué dimensiones corresponden a la longitud, ancho y profundidad. Solución Explora la distribución de precio. ¿Ves algo inusual o sorprendente? (Sugerencia: Piensa detenidamente en binwidth y asegúrate de usar un rango largo de valores.) Solución ¿Cuántos diamantes tienen 0.99 quilates? ¿Cuántos son de 1 quilate? ¿Qué piensas que puede ser la causa de dicha diferencia? Solución Compara y contrasta coord_cartesian() contra xlim() o ylim() en cuanto a acercar la imagen en un histograma. ¿Qué pasa si no modificas el valor de binwidth? ¿Qué pasa si intentas acercar la imagen de manera que solo aparezca la mitad de una barra? Solución 7.4 Valores faltantes 7.4.1 Ejercicios ¿Qué sucede con los valores faltantes en un histograma? ¿Qué pasa con los valores faltantes en una gráfica de barras? ¿Cuál es la razón detrás de esta diferencia? Solución ¿Qué efecto tiene usar na.rm = TRUE en mean() (media) y sum()(suma)? Solución 7.5 Covariación 7.5.1 Una variable categórica y otra continua 7.5.1.1 Ejercicios Usa lo que has aprendido para mejorar la visualización de los tiempos de salida de los vuelos cancelados versus los no cancelados. Solución ¿Qué variable del conjunto de datos de diamantes es más importante para predecir el precio de un diamante? ¿Cómo está correlacionada esta variable con el corte? ¿Por qué la combinación de estas dos relaciones conlleva que los diamantes de menor calidad sean más costosos? Solución Instala el paquete ggstance, y crea un diagrama de caja horizontal. ¿Cómo se compara esto a usar coord_flip()? Solución Un problema con los diagramas de caja es que fueron desarrollados en un tiempo en que los sets de datos eran más pequeños y por ende tienden a mostrar un número muy grande de “valores atípicos”. Una estrategia para remediar este problema es el diagrama letter value. Instala el paquete lvplot, e intenta usar geom_lv() para mostrar la distribución de precio vs corte. ¿Qué observas? ¿Cómo intepretas los gráficos? Solución Compara y contrasta geom_violin() con un geom_histogram() dividido en facetas, o un geom_freqpoly() codificado por colores. ¿Cuáles son las ventajas y desventajas de cada método? Solución Si tu set de datos es pequeño, a veces resulta útil usar geom_jitter() para ver la relación entre una variable continua y una discreta. El paquete ggbeeswarm provee de un número de métodos similares a geom_jitter(). Enlístalos y describe brevemente qué hace cada uno. Solución 7.5.2 Dos variables categóricas 7.5.2.1 Ejercicios ¿Cómo podrías cambiar la escala del conjunto de datos anterior para mostrar de manera más clara la distribución del corte dentro del color, o del color dentro de la variable corte? Solución Usa geom_tile() junto con dplyr para explorar la variación del retraso promedio de los vuelos en relación al destino y mes del año. ¿Qué hace que este gráfico sea difícil de leer? ¿Cómo podrías mejorarlo? Solución ¿Por qué es un poco mejor usar aes(x = color, y = corte) en lugar de aes(x = corte, y = color) en el ejemplo anterior? Solución 7.5.3 Dos variables continuas 7.5.3.1 Ejercicios En lugar de resumir la distribución condicional con un diagrama de caja, podrías usar un polígono de frecuencia. ¿Qué deberías considerar cuando usas cut_width() en comparación con cut_number()? ¿Qué impacto tiene este parámetro en la visualización bidimensional de quilate y precio? Solución Visualiza la distribución de quilate, segmentada según la variable precio. Solución ¿Cómo es la distribución del precio de diamantes muy grandes en comparación con aquella de diamantes más pequeños? ¿Es como esperabas, o te resulta sorprendente? Solución Combina dos de las técnicas que has aprendido para visualizar la distribución combinada de las variables corte, quilate y precio. Solución Los gráficos bidimensionales revelan observaciones atípicas que podrían no ser visibles en gráficos unidimensionales. Por ejemplo, algunos puntos en la gráfica a continuación tienen una combinación inusual de valores x y y, que hace que algunos puntos sean valores atípicos aún cuando sus valores x e y parecen normales cuando son examinados de manera individual. ggplot(data = diamantes) + geom_point(mapping = aes(x = x, y = y)) + coord_cartesian(xlim = c(4, 11), ylim = c(4, 11)) ¿Por qué es mejor usar un diagrama de dispersión que un diagrama basado en rangos en este caso? Solución "],["workflow-projects.html", "8 Workflow: projects", " 8 Workflow: projects Este capítulo no incluye ejercicios. "],["introducción-5.html", "9 Introducción", " 9 Introducción Esta sección no tiene ejercicios. "],["tibbles.html", "10 Tibbles 10.5 Ejercicios", " 10 Tibbles 10.5 Ejercicios ¿Cómo puedes saber si un objeto es un tibble? (Sugerencia: imprime mtautos en la consola, que es un data frame clásico). Solución Los objetos que son tibbles lo indican cuando se imprimen en la consola. Por ejemplo, vuelos es un tibble: vuelos #&gt; # A tibble: 336,776 × 19 #&gt; anio mes dia horario_salida salida_programada atraso_salida #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 2013 1 1 517 515 2 #&gt; 2 2013 1 1 533 529 4 #&gt; 3 2013 1 1 542 540 2 #&gt; 4 2013 1 1 544 545 -1 #&gt; 5 2013 1 1 554 600 -6 #&gt; 6 2013 1 1 554 558 -4 #&gt; # … with 336,770 more rows, and 13 more variables: horario_llegada &lt;int&gt;, #&gt; # llegada_programada &lt;int&gt;, atraso_llegada &lt;dbl&gt;, aerolinea &lt;chr&gt;, #&gt; # vuelo &lt;int&gt;, codigo_cola &lt;chr&gt;, origen &lt;chr&gt;, destino &lt;chr&gt;, #&gt; # tiempo_vuelo &lt;dbl&gt;, distancia &lt;dbl&gt;, hora &lt;dbl&gt;, minuto &lt;dbl&gt;, #&gt; # fecha_hora &lt;dttm&gt; mtautos, en cambio, es un data frame clásico: mtautos #&gt; millas cilindros cilindrada caballos eje peso velocidad #&gt; Mazda RX4 21.0 6 160.0 110 3.90 2.62 16.5 #&gt; Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.88 17.0 #&gt; Datsun 710 22.8 4 108.0 93 3.85 2.32 18.6 #&gt; Hornet 4 Drive 21.4 6 258.0 110 3.08 3.21 19.4 #&gt; Hornet Sportabout 18.7 8 360.0 175 3.15 3.44 17.0 #&gt; Valiant 18.1 6 225.0 105 2.76 3.46 20.2 #&gt; Duster 360 14.3 8 360.0 245 3.21 3.57 15.8 #&gt; Merc 240D 24.4 4 146.7 62 3.69 3.19 20.0 #&gt; Merc 230 22.8 4 140.8 95 3.92 3.15 22.9 #&gt; Merc 280 19.2 6 167.6 123 3.92 3.44 18.3 #&gt; Merc 280C 17.8 6 167.6 123 3.92 3.44 18.9 #&gt; Merc 450SE 16.4 8 275.8 180 3.07 4.07 17.4 #&gt; Merc 450SL 17.3 8 275.8 180 3.07 3.73 17.6 #&gt; Merc 450SLC 15.2 8 275.8 180 3.07 3.78 18.0 #&gt; Cadillac Fleetwood 10.4 8 472.0 205 2.93 5.25 18.0 #&gt; Lincoln Continental 10.4 8 460.0 215 3.00 5.42 17.8 #&gt; Chrysler Imperial 14.7 8 440.0 230 3.23 5.34 17.4 #&gt; Fiat 128 32.4 4 78.7 66 4.08 2.20 19.5 #&gt; Honda Civic 30.4 4 75.7 52 4.93 1.61 18.5 #&gt; Toyota Corolla 33.9 4 71.1 65 4.22 1.83 19.9 #&gt; Toyota Corona 21.5 4 120.1 97 3.70 2.46 20.0 #&gt; Dodge Challenger 15.5 8 318.0 150 2.76 3.52 16.9 #&gt; AMC Javelin 15.2 8 304.0 150 3.15 3.44 17.3 #&gt; Camaro Z28 13.3 8 350.0 245 3.73 3.84 15.4 #&gt; Pontiac Firebird 19.2 8 400.0 175 3.08 3.85 17.1 #&gt; Fiat X1-9 27.3 4 79.0 66 4.08 1.94 18.9 #&gt; Porsche 914-2 26.0 4 120.3 91 4.43 2.14 16.7 #&gt; Lotus Europa 30.4 4 95.1 113 3.77 1.51 16.9 #&gt; Ford Pantera L 15.8 8 351.0 264 4.22 3.17 14.5 #&gt; Ferrari Dino 19.7 6 145.0 175 3.62 2.77 15.5 #&gt; Maserati Bora 15.0 8 301.0 335 3.54 3.57 14.6 #&gt; Volvo 142E 21.4 4 121.0 109 4.11 2.78 18.6 #&gt; forma transmision cambios carburadores #&gt; Mazda RX4 0 1 4 4 #&gt; Mazda RX4 Wag 0 1 4 4 #&gt; Datsun 710 1 1 4 1 #&gt; Hornet 4 Drive 1 0 3 1 #&gt; Hornet Sportabout 0 0 3 2 #&gt; Valiant 1 0 3 1 #&gt; Duster 360 0 0 3 4 #&gt; Merc 240D 1 0 4 2 #&gt; Merc 230 1 0 4 2 #&gt; Merc 280 1 0 4 4 #&gt; Merc 280C 1 0 4 4 #&gt; Merc 450SE 0 0 3 3 #&gt; Merc 450SL 0 0 3 3 #&gt; Merc 450SLC 0 0 3 3 #&gt; Cadillac Fleetwood 0 0 3 4 #&gt; Lincoln Continental 0 0 3 4 #&gt; Chrysler Imperial 0 0 3 4 #&gt; Fiat 128 1 1 4 1 #&gt; Honda Civic 1 1 4 2 #&gt; Toyota Corolla 1 1 4 1 #&gt; Toyota Corona 1 0 3 1 #&gt; Dodge Challenger 0 0 3 2 #&gt; AMC Javelin 0 0 3 2 #&gt; Camaro Z28 0 0 3 4 #&gt; Pontiac Firebird 0 0 3 2 #&gt; Fiat X1-9 1 1 4 1 #&gt; Porsche 914-2 0 1 5 2 #&gt; Lotus Europa 1 1 5 2 #&gt; Ford Pantera L 0 1 5 4 #&gt; Ferrari Dino 0 1 5 6 #&gt; Maserati Bora 0 1 5 8 #&gt; Volvo 142E 1 1 4 2 También se puede utilizar la función is_tibble() para comprobar si un objeto lo es: is_tibble(vuelos) #&gt; [1] TRUE is_tibble(mtautos) #&gt; [1] FALSE Compara y contrasta las siguientes operaciones aplicadas a un data.frame y a un tibble equivalente. ¿Qué es diferente? ¿Por qué podría causarte problemas el comportamiento por defecto del data frame? df &lt;- data.frame(abc = 1, xyz = &quot;a&quot;) df$x df[, &quot;xyz&quot;] df[, c(&quot;abc&quot;, &quot;xyz&quot;)] Solución df &lt;- data.frame(abc = 1, xyz = &quot;a&quot;) df$x #&gt; [1] &quot;a&quot; df[, &quot;xyz&quot;] #&gt; [1] &quot;a&quot; df[, c(&quot;abc&quot;, &quot;xyz&quot;)] #&gt; abc xyz #&gt; 1 1 a Ahora, convirtamos df en un tibble: tbl &lt;- as_tibble(df) Y apliquemos las mismas operaciones: df$x #&gt; [1] &quot;a&quot; df[, &quot;xyz&quot;] #&gt; [1] &quot;a&quot; df[, c(&quot;abc&quot;, &quot;xyz&quot;)] #&gt; abc xyz #&gt; 1 1 a Si tienes el nombre de una variable guardada en un objeto, p.e., var &lt;- \"horario_salida\", ¿cómo puedes extraer esta variable de un tibble? Solución Para exatraerla como tibble: vuelos[,var] Para extraer los valores vuelos[[var]] Practica referenciar nombres no sintácticos en el siguiente data frame: molesto &lt;- tibble( `1` = 1:10, `2` = `1` * 2 + rnorm(length(`1`)) ) Extrayendo la variable llamada 1. molesto$`1` #&gt; [1] 1 2 3 4 5 6 7 8 9 10 o molesto[[&quot;1&quot;]] #&gt; [1] 1 2 3 4 5 6 7 8 9 10 Generando un gráfico de dispersión de 1 vs 2. ggplot(molesto, aes(x = `1`, y = `2`)) + geom_point() Creando una nueva columna llamada 3 que sea el resultado de la división de 2 por 1. molesto &lt;- mutate(molesto, `3` = `2` / `1`) Renombrando las columnas como uno, dos y tres. rename(molesto, uno = `1`, dos = `2`, tres = `3`) #&gt; # A tibble: 10 × 3 #&gt; uno dos tres #&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 0.600 0.600 #&gt; 2 2 4.26 2.13 #&gt; 3 3 3.56 1.19 #&gt; 4 4 7.99 2.00 #&gt; 5 5 10.6 2.12 #&gt; 6 6 13.1 2.19 #&gt; # … with 4 more rows ¿Qué hace tibble::enframe()? ¿Cuándo lo usarías? Solución La función enframe() del paquete tibble permite convertir vectores nombrados o listas en data frames de una o dos columnas. Las columnas creadas tienen por nombre name (nombres) y value (valor). enframe(c(a = 5, b = 7, c = 9, d = 11)) #&gt; # A tibble: 4 × 2 #&gt; name value #&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 a 5 #&gt; 2 b 7 #&gt; 3 c 9 #&gt; 4 d 11 ¿Qué opción controla cuántos nombres de columnas adicionales se muestran al pie de un tibble? Solución A través del argumento n_extra se puede controlar cuántas columnas adicionales mostrar. print(vuelos, n_extra = 3) #&gt; Warning: The `n_extra` argument of `print()` is deprecated as of pillar 1.6.2. #&gt; Please use the `max_extra_cols` argument instead. #&gt; # A tibble: 336,776 × 19 #&gt; anio mes dia horario_salida salida_programada atraso_salida #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 2013 1 1 517 515 2 #&gt; 2 2013 1 1 533 529 4 #&gt; 3 2013 1 1 542 540 2 #&gt; 4 2013 1 1 544 545 -1 #&gt; 5 2013 1 1 554 600 -6 #&gt; 6 2013 1 1 554 558 -4 #&gt; # … with 336,770 more rows, and 13 more variables: horario_llegada &lt;int&gt;, #&gt; # llegada_programada &lt;int&gt;, atraso_llegada &lt;dbl&gt;, … En este enlace puedes ver más información sobre las opciones para imprimir tibbles. "],["importación-de-datos.html", "11 Importación de datos 11.2 Comenzando 11.3 Segmentar un vector", " 11 Importación de datos 11.2 Comenzando 11.2.2 Ejercicios ¿Qué función utilizarías para leer un archivo donde los campos están separados con “|”? Solución La función read_delim() permite leer archivos delimitados por distintos tipos de caracteres. A través del argumento delim = indicado cuál es el caracter que se ha utilizado en el archivo que nos interesa importar. Por ejemplo: read_delim(&quot;nombre_archivo&quot;, delim = &quot;|&quot;) Además de file, skip y comment ¿Qué otros argumentos tienen en común read_csv() y read_tsv()? Solución Los argumentos que tienen en común, además de los ya mencionados, son los siguientes: delim, que permite indicar el caracter de separación. quote, para indicar el caracter utilizado para citar cadenas de caracteres (por ejemplo, \" o ') escape_backslash, para indicar si se han utilizado barras invertidas (\\) para escapar caracteres especiales. escape_double, para indicar si el archivo escapa las comillas duplicándolas (\"\"\"\") col_names, para especificar el nombre de las columnas (TRUE: asume la primera línea como nombre de columa; FALSE: genera automáticamente nombres del tipo X1, X2, X3, etc.). Si se provee un vector de caracteres, esos valores serán utilizados como nombres de columa. col_types, para indicar de cómo debe definirse el tipo de columna en cada caso. El valor NULL es el que viene por defecto y define el tipo de columna según lo que identifica en las 1000 primeras filas. Con cols() se puede indicar cómo debe leerse cada columna. locale, para controlar los parámetros por defecto que varían según zona (por ejemplo, zona geográfica, codificación de caracteres, marca de decimal, nombre de días/meses, etc.) na, para indicar qué cadena de caracteres se utiliza en el archivo para marcar valores faltantes. quoted_na, para indicar si los valores faltantes que están dentro de una cadena de caracteres entrecomilladas deben interpretarse como tales. trim_ws, si queremos que los espacios en blanco antes y después de cada campo se eliminen previo a la segmentación del archivo en columnas. n_max, para definir el máximo de filas que se deben leer guess_max, para indicar cuál es el número máximo de valores a considerar para inferir el tipo de columna (el valor por defecto es 1000) progress, para indicar si queremos que se muestre una barra de progreso al importar el archivo. skip_empty_rows, para señalar que las filas en blanco deben omitirse al leer el archivo. ¿Cuáles son los argumentos más importantes de read_fwf()? Solución read_fwf() es una función para leer archivos en que las columnas tienen un ancho fijo (fwf: fixed-width format). Es por eso que sus argumentos más importantes son las que permiten indicar la posición de las columnas: col_positions. A través de ella podemos elegir que adivine la posición según las columnas vacías, o definirlas indicando el ancho de cada columna o el inicio y fin de cada una. Algunas veces, las cadenas de caracteres en un archivo csv contienen comas. Para evitar que causen problemas deben estar rodeadas por comillas, como \" o '. Por convención, read_csv() asume que el caracter de separación será \", y si quieres cambiarlo necesitarás usar read_delim() en su lugar.¿Qué argumentos debes especificar para leer el siguiente texto en un data frame? &quot;x,y\\n1,&#39;a,b&#39;&quot; Solución Necesitamos indicar cuál es el caracter que se ha utilizado como delimitador. datos &lt;- &quot;x,y\\n1,&#39;a,b&#39;&quot; read_delim(datos, delim = &quot;,&quot;, quote = &quot;&#39;&quot;) #&gt; Rows: 1 Columns: 2 #&gt; ── Column specification ──────────────────────────────────────────────────────── #&gt; Delimiter: &quot;,&quot; #&gt; chr (1): y #&gt; dbl (1): x #&gt; #&gt; ℹ Use `spec()` to retrieve the full column specification for this data. #&gt; ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. #&gt; # A tibble: 1 × 2 #&gt; x y #&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 1 a,b Identifica qué está mal en cada una de los siguientes archivos csv alineados. ¿Qué pasa cuando corres el código? read_csv(&quot;a,b\\n1,2,3\\n4,5,6&quot;) read_csv(&quot;a,b,c\\n1,2\\n1,2,3,4&quot;) read_csv(&quot;a,b\\n\\&quot;1&quot;) read_csv(&quot;a,b\\n1,2\\na,b&quot;) read_csv(&quot;a;b\\n1;3&quot;) Solución En los tres primeros casos hay problemas porque la cantidad de columnas esperadas (expected) y la que se encuetra en los datos (actual) no coincide. En el primer caso, se esperan dos columnas, pero las filas 1 y 2 tienen tres valores. El último, por lo tanto, se descarta. read_csv(&quot;a,b\\n1,2,3\\n4,5,6&quot;) #&gt; Warning: One or more parsing issues, see `problems()` for details #&gt; Rows: 2 Columns: 2 #&gt; ── Column specification ──────────────────────────────────────────────────────── #&gt; Delimiter: &quot;,&quot; #&gt; dbl (1): a #&gt; #&gt; ℹ Use `spec()` to retrieve the full column specification for this data. #&gt; ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. #&gt; # A tibble: 2 × 2 #&gt; a b #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 23 #&gt; 2 4 56 En el segundo caso, en la fila 1 se esperan tres valores, pero solo hay dos, por lo que la tercera columna se completa con NA. En la fila dos, hay cuatro valores, por lo que el último se descarta. read_csv(&quot;a,b,c\\n1,2\\n1,2,3,4&quot;) #&gt; Warning: One or more parsing issues, see `problems()` for details #&gt; Rows: 2 Columns: 3 #&gt; ── Column specification ──────────────────────────────────────────────────────── #&gt; Delimiter: &quot;,&quot; #&gt; dbl (2): a, b #&gt; #&gt; ℹ Use `spec()` to retrieve the full column specification for this data. #&gt; ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. #&gt; # A tibble: 2 × 3 #&gt; a b c #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 2 NA #&gt; 2 1 2 34 En el tercer caso, solo hay un valor para la primera fila, por lo que se completa la segunda columna con NA. Además, se indica que falta una comilla de cierre, por lo que se descarta la ue no está cerrada (\"1). read_csv(&quot;a,b\\n\\&quot;1&quot;) #&gt; Rows: 0 Columns: 2 #&gt; ── Column specification ──────────────────────────────────────────────────────── #&gt; Delimiter: &quot;,&quot; #&gt; chr (2): a, b #&gt; #&gt; ℹ Use `spec()` to retrieve the full column specification for this data. #&gt; ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. #&gt; # A tibble: 0 × 2 #&gt; # … with 2 variables: a &lt;chr&gt;, b &lt;chr&gt; En este caso, el posible problema es que, debido a que en la segunda fila a y b son caracteres, en la primera 1 y 2 también son tratados como caracteres. read_csv(&quot;a,b\\n1,2\\na,b&quot;) #&gt; Rows: 2 Columns: 2 #&gt; ── Column specification ──────────────────────────────────────────────────────── #&gt; Delimiter: &quot;,&quot; #&gt; chr (2): a, b #&gt; #&gt; ℹ Use `spec()` to retrieve the full column specification for this data. #&gt; ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. #&gt; # A tibble: 2 × 2 #&gt; a b #&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 1 2 #&gt; 2 a b En el último caso se produce un problema habitual de lectura de archivos csv: que el delimitador no es una coma, sino punto y coma. Como la función read_csv() espera una coma como delimitador, no separa las columnas como se espera: read_csv(&quot;a;b\\n1;3&quot;) #&gt; Rows: 1 Columns: 1 #&gt; ── Column specification ──────────────────────────────────────────────────────── #&gt; Delimiter: &quot;,&quot; #&gt; chr (1): a;b #&gt; #&gt; ℹ Use `spec()` to retrieve the full column specification for this data. #&gt; ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. #&gt; # A tibble: 1 × 1 #&gt; `a;b` #&gt; &lt;chr&gt; #&gt; 1 1;3 En este caso, puede utilizarse read_csv2(), que espera un punto y coma como delimitador: read_csv2(&quot;a;b\\n1;3&quot;) #&gt; ℹ Using &quot;&#39;,&#39;&quot; as decimal and &quot;&#39;.&#39;&quot; as grouping mark. Use `read_delim()` for more control. #&gt; Rows: 1 Columns: 2 #&gt; ── Column specification ──────────────────────────────────────────────────────── #&gt; Delimiter: &quot;;&quot; #&gt; dbl (2): a, b #&gt; #&gt; ℹ Use `spec()` to retrieve the full column specification for this data. #&gt; ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. #&gt; # A tibble: 1 × 2 #&gt; a b #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 3 11.3 Segmentar un vector 11.3.5 Ejercicios ¿Cuáles son los argumentos más importantes para locale()? Solución date_names, para indicar el idioma de las fechas. es es el código para español. date_format y time_format, para indicar el formato de fecha y hora decimal_mark y grouping_mark, para definir el símbolo para separar decimales (, o .) y para segmentar números grandes. tz, para definir la zona horaria. encoding, para indicar la codificación que se quiere utilizar para leer archivos. ¿Qué pasa si pruebas y estableces decimal_mark y grouping_mark al mismo caracter? ¿Qué pasa con el valor por defecto de grouping_mark cuando seleccionas decimal_mark a ,? ¿Qué pasa con el valor por defecto de decimal_mark cuando estableces grouping_mark a .? Solución Si se define el mismo caracter para ambos, se genera un error que indica que deben ser diferentes: locale(decimal_mark = &quot;,&quot;, grouping_mark = &quot;,&quot;) # Error: `decimal_mark` and `grouping_mark` must be different Si se decimal_mark se define como , el valor por defecto de grouping_mark cambia a .. Al revés pasa lo mismo: si grouping_mark se define como . entonces decimal_mark cambia a ,. locale(decimal_mark = &quot;,&quot;) #&gt; &lt;locale&gt; #&gt; Numbers: 123.456,78 #&gt; Formats: %AD / %AT #&gt; Timezone: UTC #&gt; Encoding: UTF-8 #&gt; &lt;date_names&gt; #&gt; Days: Sunday (Sun), Monday (Mon), Tuesday (Tue), Wednesday (Wed), Thursday #&gt; (Thu), Friday (Fri), Saturday (Sat) #&gt; Months: January (Jan), February (Feb), March (Mar), April (Apr), May (May), #&gt; June (Jun), July (Jul), August (Aug), September (Sep), October #&gt; (Oct), November (Nov), December (Dec) #&gt; AM/PM: AM/PM locale(grouping_mark = &quot;.&quot;) #&gt; &lt;locale&gt; #&gt; Numbers: 123.456,78 #&gt; Formats: %AD / %AT #&gt; Timezone: UTC #&gt; Encoding: UTF-8 #&gt; &lt;date_names&gt; #&gt; Days: Sunday (Sun), Monday (Mon), Tuesday (Tue), Wednesday (Wed), Thursday #&gt; (Thu), Friday (Fri), Saturday (Sat) #&gt; Months: January (Jan), February (Feb), March (Mar), April (Apr), May (May), #&gt; June (Jun), July (Jul), August (Aug), September (Sep), October #&gt; (Oct), November (Nov), December (Dec) #&gt; AM/PM: AM/PM No discutimos las opciones date_format y time_format para locale(). ¿Qué hacen? Construye un ejemplo que muestre cuándo pueden ser útiles. Solución Como se indicó más arriba, date_format y time_format sirven para indicar el formato de fecha y hora. Por defecto, están especificados como %AD y %AT. La A es de automatic parser; se segmentan automáticamente las fechas con un formato de Año-Mes-Día (YMD), y las horas con un formato de Hora-Minuto-Segundo (HMS). Si mis datos tuviesen las fechas o las horas escritas en otro formato, podría ajustar estas opciones. Por ejemplo, en este caso el orden es día/mes/año, por lo que no reconoce que es una fecha read_csv(&quot;fecha\\n01/01/2020\\n01/02/2020&quot;) #&gt; Rows: 2 Columns: 1 #&gt; ── Column specification ──────────────────────────────────────────────────────── #&gt; Delimiter: &quot;,&quot; #&gt; chr (1): fecha #&gt; #&gt; ℹ Use `spec()` to retrieve the full column specification for this data. #&gt; ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. #&gt; # A tibble: 2 × 1 #&gt; fecha #&gt; &lt;chr&gt; #&gt; 1 01/01/2020 #&gt; 2 01/02/2020 Si utilizamos date_format, podemos indicar que nuestros datos tienen la forma día/mes/año (%d/%m/%Y), lo que permite que sean interpretados como fecha y ajustados al formato YMD: read_csv(&quot;fecha\\n01/01/2020\\n01/02/2020&quot;, locale = locale(date_format = &quot;%d/%m/%Y&quot;)) #&gt; Rows: 2 Columns: 1 #&gt; ── Column specification ──────────────────────────────────────────────────────── #&gt; Delimiter: &quot;,&quot; #&gt; date (1): fecha #&gt; #&gt; ℹ Use `spec()` to retrieve the full column specification for this data. #&gt; ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. #&gt; # A tibble: 2 × 1 #&gt; fecha #&gt; &lt;date&gt; #&gt; 1 2020-01-01 #&gt; 2 2020-02-01 Si vives fuera de EE. UU., crea un nuevo objeto locale que encapsule las opciones para los tipos de archivo que lees más comúnmente. Solución El caso anterior es un ejemplo que puede resultar útil en contextos hispanoparlantes, en los que las fechas suelen representarse con el formato día/mes/año. Asimismo, podemos indicar que la marca de decimal es ,. Podemos crear un nuevo objeto locale con esas indicaciones: locale_latam &lt;- locale(date_format = &quot;%d/%m/%Y&quot;, decimal_mark = &quot;,&quot;) Esto permite que no se lea el . como decimal, sino solo como solo como símbolo para separar números grandes, y que las fechas se lean correctamente: read_csv(&quot;fecha,valor\\n01/01/2020,110.251\\n01/02/2020,120.285&quot;, locale = locale_latam) #&gt; Rows: 2 Columns: 2 #&gt; ── Column specification ──────────────────────────────────────────────────────── #&gt; Delimiter: &quot;,&quot; #&gt; date (1): fecha #&gt; #&gt; ℹ Use `spec()` to retrieve the full column specification for this data. #&gt; ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. #&gt; # A tibble: 2 × 2 #&gt; fecha valor #&gt; &lt;date&gt; &lt;dbl&gt; #&gt; 1 2020-01-01 110251 #&gt; 2 2020-02-01 120285 ¿Cuál es la diferencia entre read_csv() y read_csv2()? Solución Lo mencionamos al pasar más arriba: read_csv() utiliza , como delimitador y read_csv2() utiliza ;. read_csv2() es muy útil en el contexto hispanoparlante, ya que utilizamos la coma como separador de decimales, no el punto. Cuando tenemos datos con ese formato, podemos usar ; para separar los valores. ¿Cuáles son las codificaciones más comunes empleadas en Europa? ¿Cuáles son las codificaciones más comunes utilizadas en Asia? Googlea un poco para descubrirlo. Solución Genera el formato correcto para leer cada una de las siguientes fechas y horas: d1 &lt;- &quot;January 1, 2010&quot; d2 &lt;- &quot;2015-Mar-07&quot; d3 &lt;- &quot;06-Jun-2017&quot; d4 &lt;- c(&quot;August 19 (2015)&quot;, &quot;July 1 (2015)&quot;) d5 &lt;- &quot;12/30/14&quot; # Dec 30, 2014 t1 &lt;- &quot;1705&quot; t2 &lt;- &quot;11:15:10.12 PM&quot; Solución Las especificaciones que necesitamos para leer las fechas son las siguientes: parse_date(d1, &quot;%B %d, %Y&quot;) #&gt; [1] &quot;2010-01-01&quot; parse_date(d2, &quot;%Y-%b-%d&quot;) #&gt; [1] &quot;2015-03-07&quot; parse_date(d3, &quot;%d-%b-%Y&quot;) #&gt; [1] &quot;2017-06-06&quot; parse_date(d4, &quot;%B %d (%Y)&quot;) #&gt; [1] &quot;2015-08-19&quot; &quot;2015-07-01&quot; parse_date(d5, &quot;%m/%d/%y&quot;) #&gt; [1] &quot;2014-12-30&quot; parse_time(t1, &quot;%H%M&quot;) #&gt; 17:05:00 parse_time(t2, &quot;%H:%M:%OS %p&quot;) #&gt; 23:15:10.12 "],["datos-ordenados.html", "12 Datos ordenados 12.2 Datos ordenados 12.3 Pivotar 12.4 Separar y unir 12.5 Valores faltantes 12.6 Estudio de caso", " 12 Datos ordenados 12.2 Datos ordenados 12.2.1 Ejercicios Usando prosa, describe como las variables y observaciones se organizan en las tablas de ejemplo. Solución Calcula la tasa para las tablas tabla2 y tabla4a + tabla4b. Necesitarás las siguientes operaciones: Extrae el número de casos de tuberculosis por país y año. Extrae la población por país y año. Divide los casos por la población y multiplica por 10000. Inserta los datos en el lugar adecuado. ¿Cuál representación es más fácil de trabajar? ¿Cuál es la más difícil? ¿Por qué? Solución Recrea el gráfico que muestra el cambio en el número de casos usando la tabla2 en lugar de la tabla1. ¿Qué debes hacer en primer lugar? Solución 12.3 Pivotar 12.3.3 Ejercicios ¿Por qué pivot_longer() y pivot_wider() no son perfectamente simétricas? Observa cuidadosamente el siguiente ejemplo: acciones &lt;- tibble( anio = c(2015, 2015, 2016, 2016), semestre = c(1, 2, 1, 2), retorno = c(1.88, 0.59, 0.92, 0.17) ) acciones %&gt;% pivot_wider(names_from = anio, values_from = retorno) %&gt;% pivot_longer(`2015`:`2016`, names_to = &quot;anio&quot;, values_to = &quot;retorno&quot;) (Pista: observa los tipos de variables y piensa en los nombres de las columnas) pivot_longer() y pivot_wider() tienen el argumento names_ptype. Por ejemplo, names_ptype = list(year = double()). ¿Qué es lo que hace dicho argumento? Solución ¿Por qué falla el siguiente código? tabla4a %&gt;% pivot_longer(c(1999, 2000), names_to = &quot;anio&quot;, values_to = &quot;casos&quot;) #&gt; Error: Can&#39;t subset columns that don&#39;t exist. #&gt; x Locations 1999 and 2000 don&#39;t exist. #&gt; ℹ There are only 3 columns. Solución El código falla porque los nombres de las columnas 1999 y 2000 deben escribirse rodeados de tildes graves, ya que son nombres “no sintácticos”: tabla4a %&gt;% pivot_longer(c(`1999`, `2000`), names_to = &quot;anio&quot;, values_to = &quot;casos&quot;) #&gt; # A tibble: 6 × 3 #&gt; pais anio casos #&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 Afganistán 1999 745 #&gt; 2 Afganistán 2000 2666 #&gt; 3 Brasil 1999 37737 #&gt; 4 Brasil 2000 80488 #&gt; 5 China 1999 212258 #&gt; 6 China 2000 213766 ¿Por qué no se puede extender la siguiente tabla? ¿Cómo agregarías una nueva columna para resolver el problema? personas &lt;- tribble( ~nombre, ~clave, ~valor, #-----------------|--------|------ &quot;Phillip Woods&quot;, &quot;edad&quot;, 45, &quot;Phillip Woods&quot;, &quot;estatura&quot;, 186, &quot;Phillip Woods&quot;, &quot;edad&quot;, 50, &quot;Jessica Cordero&quot;, &quot;edad&quot;, 37, &quot;Jessica Cordero&quot;, &quot;estatura&quot;, 156 ) Solución Ordena la siguiente tabla. ¿Necesitas extenderla o contraerla? ¿Cuáles son las variables? embarazo &lt;- tribble( ~embarazo, ~hombre, ~mujer, &quot;sí&quot;, NA, 10, &quot;no&quot;, 20, 12 ) Solución La tabla muestra la cantidad de embarazon por género. Las variables serían embarazo, genero y una tercera a la que podemos llamar n. Para que la tabla quede ordenada tenemos que “alargarla”: embarazo %&gt;% pivot_longer(c(hombre, mujer), names_to = &quot;genero&quot;, values_to = &quot;n&quot;) #&gt; # A tibble: 4 × 3 #&gt; embarazo genero n #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 sí hombre NA #&gt; 2 sí mujer 10 #&gt; 3 no hombre 20 #&gt; 4 no mujer 12 12.4 Separar y unir 12.4.3 Ejercicios ¿Qué hacen los argumentos extra y fill en separate()? Experimenta con las diversas opciones a partir de los siguientes datasets de ejemplo. tibble(x = c(&quot;a,b,c&quot;, &quot;d,e,f,g&quot;, &quot;h,i,j&quot;)) %&gt;% separate(x, c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)) tibble(x = c(&quot;a,b,c&quot;, &quot;d,e&quot;, &quot;f,g,i&quot;)) %&gt;% separate(x, c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)) Solución Tanto unite() como separate() tienen un argumento remove. ¿Qué es lo que hace? ¿Por qué lo dejarías en FALSE? Solución Compara y contrasta separate() y extract(). ¿Por qué existen tres variaciones de separación (por posición, separador y grupos), pero solo una forma de unir? Solución 12.5 Valores faltantes 12.5.1 Ejercicios Compara y contrasta el argumento fill que se usa en spread() con complete(). Solución ¿Qué hace el argumento de dirección en fill()? Solución 12.6 Estudio de caso 12.6.1 Ejercicios En este caso de estudio fijamos na.rm = TRUE para simplificar la verificación de que tenemos los valores correctos. ¿Es esto razonable? Piensa en como los valores faltantes están representados en este dataset. ¿Existen valores faltantes implícitos? ¿Cuál es la diferencia entre NA y cero? Solución ¿Qué ocurre si omites la aplicación de mutate()? (mutate(clave = stringr::str_replace(clave, \"nuevosrecaida\", \"nuevos_recaida\"))) Solución Afirmamos que iso2 e iso3 son redundantes respecto a pais. Confirma esta premisa. Solución Para cada país, año y sexo calcula el total del número de casos de tuberculosis. Crea una visualización informativa de los datos. Solución "],["datos-relacionales.html", "13 Datos relacionales 13.2 Datos sobre vuelos 13.3 Claves 13.1 13.4 Uniones de transformación 13.2 13.5 Uniones de filtro", " 13 Datos relacionales 13.2 Datos sobre vuelos 13.2.1 Ejercicios Imagina que necesitas dibujar (aproximadamente) la ruta que cada avión vuela desde su origen hasta el destino. ¿Qué variables necesitas? ¿Qué tablas necesitas combinar? Solución Necesitas combinar aeropuertos con vuelos ya que el dataset aeropuertos contiene las coordenadas de los aeropuertos. Puedes unir las tablas por medio de la variable codigo_aeropuerto en aeropuertos y origen y destino en vuelos. Olvidamos incluir la relación entre clima y aeropuertos. ¿Cuál es la relación y cómo debe aparecer en el diagrama? Solución De manera similar al ejercicio anterior, se pueden unir mediante codigo_aeropuerto en aeropuertos y origen en clima. clima únicamente contiene información de los aeropuertos de origen (Nueva York). Si contuviera registros para todos los aeropuertos de EEUU, ¿Qué relación tendría con vuelos? Solución Puedes conectar clima con vuelos usando la columna destino e incluir el clima de los aeropuertos de EEUU que están presentes en la tabla vuelos. Sabemos que hay días “especiales” en el año y pocas personas vuelan esos días. ¿Cómo se representarían en un data frame? ¿Cuáles serían las claves primarias de esa tabla? ¿Cómo se conectaría con las tablas existentes? Solución Una posibilidad es contar con un dataset de los días festivos en EEUU indicando mes y día. Esta información se puede unir con cada vuelo en la tabla vuelos y y a la vez con el dataset clima. 13.3 Claves 13.3.1 Ejercicios Agrega una clave subrogada a vuelos. Solución vuelos %&gt;% mutate(id = row_number(anio)) %&gt;% select(id, everything()) #&gt; # A tibble: 336,776 × 20 #&gt; id anio mes dia horario_salida salida_programada atraso_salida #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 1 2013 1 1 517 515 2 #&gt; 2 2 2013 1 1 533 529 4 #&gt; 3 3 2013 1 1 542 540 2 #&gt; 4 4 2013 1 1 544 545 -1 #&gt; 5 5 2013 1 1 554 600 -6 #&gt; 6 6 2013 1 1 554 558 -4 #&gt; # … with 336,770 more rows, and 13 more variables: horario_llegada &lt;int&gt;, #&gt; # llegada_programada &lt;int&gt;, atraso_llegada &lt;dbl&gt;, aerolinea &lt;chr&gt;, #&gt; # vuelo &lt;int&gt;, codigo_cola &lt;chr&gt;, origen &lt;chr&gt;, destino &lt;chr&gt;, #&gt; # tiempo_vuelo &lt;dbl&gt;, distancia &lt;dbl&gt;, hora &lt;dbl&gt;, minuto &lt;dbl&gt;, #&gt; # fecha_hora &lt;dttm&gt; Identifica las claves en los siguientes conjuntos de datos datos::bateadores datos::nombres datos::atmosfera datos::vehiculos datos::diamantes (Puede que necesites leer un poco de documentación.) Solución En datos::bateadores corresponde a id_jugador. En datos::nombres corresponde a la combinación de anio y nombre, con esto se puede unir cada par año-nombre con las otras tablas. En datos::atmosfera corresponde a latitud,longitud,anioymes`, lo cual identifica de manera única un lugar en el tiempo. En datos::vehiculos corresponde a id. En datos::diamantes no hay claves ya que estas tienen sentido en datos relacionales, es decir cuando existen otras tablas para combinar información. Dibuja un diagrama que ilustre las conexiones entre las tablas bateadores, personas y salarios en el paquete datos. Dibuja otro diagrama que muestre la relación entre personas, dirigentes y premios_dirigentes. ¿Cómo caracterizarías las relación entre bateadores, lanzadores y jardineros? Solución Es directo. Las tres tablas contienen los campos id_jugador y anio y cada tabla contiene información que complementa las demás. La relación es uno a uno. 13.1 13.4 Uniones de transformación 13.4.6 Ejercicios Calcula el atraso promedio por destino, luego une los datos en aeropuertos para que puedas mostrar la distribución espacial de los atrasos. Te presentamos una forma fácil de dibujar un mapa de los Estados Unidos: aeropuertos %&gt;% semi_join(vuelos, c(&quot;codigo_aeropuerto&quot; = &quot;destino&quot;)) %&gt;% ggplot(aes(longitud, latitud)) + borders(&quot;state&quot;) + geom_point() + coord_quickmap() (No te preocupes si no entiendes que hace semi_join(). Lo aprenderás a continuación.) Quizás quieras usar size o colour para editar los puntos y mostrar el atraso promedio de cada aeropuerto. Solución atraso_promedio_destino &lt;- vuelos %&gt;% group_by(destino) %&gt;% # los vuelos con NA en atraso_llegada son vuelos cancelados summarise(atraso = mean(atraso_llegada, na.rm = TRUE)) %&gt;% inner_join(aeropuertos, by = c(destino = &quot;codigo_aeropuerto&quot;)) atraso_promedio_destino %&gt;% ggplot(aes(longitud, latitud, colour = atraso)) + borders(&quot;state&quot;) + geom_point() + coord_quickmap() Agrega la ubicación de origen y destino (e.g. latitud y longitud) a vuelos. Solución Es posible realizar varias uniones. Si hay variables duplicadas, dplyr va a distinguirlas agregando .x y .y al nombre de la variable para resolver los nombres duplicados. ubicacion_aeropuertos &lt;- aeropuertos %&gt;% select(codigo_aeropuerto, latitud, longitud) vuelos %&gt;% select(anio:dia, hora, origen, destino) %&gt;% left_join( ubicacion_aeropuertos, by = c(&quot;origen&quot; = &quot;codigo_aeropuerto&quot;) ) %&gt;% left_join( ubicacion_aeropuertos, by = c(&quot;destino&quot; = &quot;codigo_aeropuerto&quot;) ) #&gt; # A tibble: 336,776 × 10 #&gt; anio mes dia hora origen destino latitud.x longitud.x latitud.y #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 2013 1 1 5 EWR IAH 40.7 -74.2 30.0 #&gt; 2 2013 1 1 5 LGA IAH 40.8 -73.9 30.0 #&gt; 3 2013 1 1 5 JFK MIA 40.6 -73.8 25.8 #&gt; 4 2013 1 1 5 JFK BQN 40.6 -73.8 NA #&gt; 5 2013 1 1 6 LGA ATL 40.8 -73.9 33.6 #&gt; 6 2013 1 1 5 EWR ORD 40.7 -74.2 42.0 #&gt; # … with 336,770 more rows, and 1 more variable: longitud.y &lt;dbl&gt; Es una buena práctica tener nombres indicativos para las variables. Usaremos el sufijo _destino y _origen para especificar a qué aeropuerto nos referimos. vuelos %&gt;% select(anio:dia, hora, origen, destino) %&gt;% left_join( ubicacion_aeropuertos, by = c(&quot;origen&quot; = &quot;codigo_aeropuerto&quot;) ) %&gt;% left_join( ubicacion_aeropuertos, by = c(&quot;destino&quot; = &quot;codigo_aeropuerto&quot;), suffix = c(&quot;_origen&quot;, &quot;_destino&quot;) ) #&gt; # A tibble: 336,776 × 10 #&gt; anio mes dia hora origen destino latitud_origen longitud_origen #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 2013 1 1 5 EWR IAH 40.7 -74.2 #&gt; 2 2013 1 1 5 LGA IAH 40.8 -73.9 #&gt; 3 2013 1 1 5 JFK MIA 40.6 -73.8 #&gt; 4 2013 1 1 5 JFK BQN 40.6 -73.8 #&gt; 5 2013 1 1 6 LGA ATL 40.8 -73.9 #&gt; 6 2013 1 1 5 EWR ORD 40.7 -74.2 #&gt; # … with 336,770 more rows, and 2 more variables: latitud_destino &lt;dbl&gt;, #&gt; # longitud_destino &lt;dbl&gt; ¿Existe una relación entre la antiguedad de un avión y sus atrasos? Solución Ya que no se indica si se refiere a atrasos de salida o llegada, se explorará el atraso en la salida, quedando el otro caso como ejercicio. Para comparar la antiguedad de un avión con sus atrasos, hay que unir vuelos con aviones, esta última tabla contiene la variable anio que se refiere al año de fabricación del avión. Dado que hay pocos aviones de más de 25 años, truncaremos los datos y luego vamos a calcular el promedio de llegada y salida dada la antiguedad. atrasos_por_antiguedad &lt;- inner_join(vuelos, select(aviones, codigo_cola, anio_fabricacion = anio), by = &quot;codigo_cola&quot;) %&gt;% mutate(antiguedad = anio - anio_fabricacion) %&gt;% filter(!is.na(antiguedad)) %&gt;% mutate(antiguedad = if_else(antiguedad &gt; 25, 25L, antiguedad)) %&gt;% group_by(antiguedad) %&gt;% summarise( prom_atraso_salida = mean(atraso_salida, na.rm = TRUE), desv_est_atraso_salida = sd(atraso_salida, na.rm = TRUE), nro_vuelos_atrasados_salida = sum(!is.na(atraso_salida)) ) Ahora podemos explorar la reglación entre los atrasos en la salida y la antiguedad. El atraso en la salida es creciente en relación a la antiguedad para los aviones de hasta de 10 años. Luego este atraso decae. La reducción de los atrasos en la salida en relación a la antiguedad puede deberse a que en los aviones más antiguos se planfica la mantención para evitar tales atrasos y desperfectos mecánicos. ggplot(atrasos_por_antiguedad, aes(x = antiguedad, y = prom_atraso_salida)) + geom_point() + scale_x_continuous(&quot;Antiguedad del avión (años)&quot;, breaks = seq(0, 30, by = 10)) + scale_y_continuous(&quot;Atraso promedio en la salida (minutos)&quot;) ¿Qué condiciones climáticas hacen más probables los atrasos? Solución Las lluvias están asociadas con los atrasos. Sin embargo, para un nivel mayor a 0.02 pulgadas de lluvia no hay una tendencia fuerte. vuelo_clima &lt;- vuelos %&gt;% inner_join(clima, by = c( &quot;origen&quot;, &quot;anio&quot;, &quot;mes&quot;, &quot;dia&quot;, &quot;hora&quot; )) vuelo_clima %&gt;% group_by(precipitacion) %&gt;% summarise(atraso = mean(atraso_salida, na.rm = TRUE)) %&gt;% ggplot(aes(x = precipitacion, y = atraso)) + geom_line() + geom_point() ¿Qué sucedió el día 13 de junio de 2013? Muestra el patrón espacial de los atrasos, luego usa un buscador para encontrar referencias cruzadas con el clima. Solución Hubo una serie de tormentas en el sureste de los EEUU (consulta la Wikipedia). El siguiente gráfico muestra que los mayores atrasos se presentaron en Tennessee (Nashville), el sureste y medio oeste es donde ocurrieron las tormentas. vuelos %&gt;% filter(anio == 2013, mes == 6, dia == 13) %&gt;% group_by(destino) %&gt;% summarise(atraso = mean(atraso_salida, na.rm = TRUE)) %&gt;% inner_join(aeropuertos, by = c(&quot;destino&quot; = &quot;codigo_aeropuerto&quot;)) %&gt;% ggplot(aes(y = latitud, x = longitud, size = atraso, colour = atraso)) + borders(&quot;state&quot;) + geom_point() + coord_quickmap() + scale_colour_viridis_c() #&gt; Warning: Removed 3 rows containing missing values (geom_point). 13.2 13.5 Uniones de filtro 13.5.1 Ejercicios ¿Qué significa que un vuelo no tenga codigo_cola? ¿Qué tienen en común los códigos de cola que no tienen registros coincidentes en aviones? (Pista: Una variable explica ~90% de los problemas.) Solución Los vuelos que no registran código cola tampoco registran hora de llegada, por lo que son vuelos cancelados. vuelos %&gt;% filter(is.na(codigo_cola), !is.na(horario_llegada)) %&gt;% nrow() #&gt; [1] 0 Muchos de los vuelos sin código cola en aviones pertenecen a American Airlines (AA) o Envoy Airlines (EQ) como se detalla en la documentación. vuelos %&gt;% anti_join(aviones, by = &quot;codigo_cola&quot;) %&gt;% count(aerolinea, sort = TRUE) %&gt;% mutate(p = n / sum(n)) #&gt; # A tibble: 10 × 3 #&gt; aerolinea n p #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 MQ 25397 0.483 #&gt; 2 AA 22558 0.429 #&gt; 3 UA 1693 0.0322 #&gt; 4 9E 1044 0.0198 #&gt; 5 B6 830 0.0158 #&gt; 6 US 699 0.0133 #&gt; # … with 4 more rows Sin embargo, no todos los códigos que aparecen en vuelos están perdidos en aviones. vuelos %&gt;% distinct(aerolinea, codigo_cola) %&gt;% left_join(aviones, by = &quot;codigo_cola&quot;) %&gt;% group_by(aerolinea) %&gt;% summarise(total_aviones = n(), faltan_en_aviones = sum(is.na(modelo))) %&gt;% mutate(porcentaje_perdidos = faltan_en_aviones / total_aviones) %&gt;% arrange(desc(porcentaje_perdidos)) #&gt; # A tibble: 16 × 4 #&gt; aerolinea total_aviones faltan_en_aviones porcentaje_perdidos #&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 MQ 238 234 0.983 #&gt; 2 AA 601 430 0.715 #&gt; 3 F9 26 3 0.115 #&gt; 4 FL 129 12 0.0930 #&gt; 5 UA 621 23 0.0370 #&gt; 6 US 290 9 0.0310 #&gt; # … with 10 more rows Filtra los vuelos para mostrar únicamente los aviones que han realizado al menos cien viajes. Solución Debemos calcular que aviones tienen 100 o más vuelos. Hay que filtrar los aviones sin código cola o estos se van a considerar como un único avión. cien_vuelos &lt;- vuelos %&gt;% filter(!is.na(codigo_cola)) %&gt;% group_by(codigo_cola) %&gt;% count() %&gt;% filter(n &gt;= 100) Ahora se puede unir el resultado con la tabla vuelos y así conservar los que cumplen con el criterio. vuelos %&gt;% semi_join(cien_vuelos, by = &quot;codigo_cola&quot;) #&gt; # A tibble: 228,390 × 19 #&gt; anio mes dia horario_salida salida_programada atraso_salida #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 2013 1 1 517 515 2 #&gt; 2 2013 1 1 533 529 4 #&gt; 3 2013 1 1 544 545 -1 #&gt; 4 2013 1 1 554 558 -4 #&gt; 5 2013 1 1 555 600 -5 #&gt; 6 2013 1 1 557 600 -3 #&gt; # … with 228,384 more rows, and 13 more variables: horario_llegada &lt;int&gt;, #&gt; # llegada_programada &lt;int&gt;, atraso_llegada &lt;dbl&gt;, aerolinea &lt;chr&gt;, #&gt; # vuelo &lt;int&gt;, codigo_cola &lt;chr&gt;, origen &lt;chr&gt;, destino &lt;chr&gt;, #&gt; # tiempo_vuelo &lt;dbl&gt;, distancia &lt;dbl&gt;, hora &lt;dbl&gt;, minuto &lt;dbl&gt;, #&gt; # fecha_hora &lt;dttm&gt; Otra posibilidad es agrupar y luego usar mutate(). vuelos %&gt;% filter(!is.na(codigo_cola)) %&gt;% group_by(codigo_cola) %&gt;% mutate(n = n()) %&gt;% filter(n &gt;= 100) #&gt; # A tibble: 228,390 × 20 #&gt; # Groups: codigo_cola [1,217] #&gt; anio mes dia horario_salida salida_programada atraso_salida #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 2013 1 1 517 515 2 #&gt; 2 2013 1 1 533 529 4 #&gt; 3 2013 1 1 544 545 -1 #&gt; 4 2013 1 1 554 558 -4 #&gt; 5 2013 1 1 555 600 -5 #&gt; 6 2013 1 1 557 600 -3 #&gt; # … with 228,384 more rows, and 14 more variables: horario_llegada &lt;int&gt;, #&gt; # llegada_programada &lt;int&gt;, atraso_llegada &lt;dbl&gt;, aerolinea &lt;chr&gt;, #&gt; # vuelo &lt;int&gt;, codigo_cola &lt;chr&gt;, origen &lt;chr&gt;, destino &lt;chr&gt;, #&gt; # tiempo_vuelo &lt;dbl&gt;, distancia &lt;dbl&gt;, hora &lt;dbl&gt;, minuto &lt;dbl&gt;, #&gt; # fecha_hora &lt;dttm&gt;, n &lt;int&gt; Combina vehiculos y comunes para encontrar los registros de los modelos más comunes. Solución Debemos unir por fabricante y modelo, a modo de evitar hacer un match incorrecto debido a que dos fabricantes tengan un vehículo con el mismo nombre. vehiculos %&gt;% semi_join(comunes, by = c(&quot;fabricante&quot;, &quot;modelo&quot;)) #&gt; # A tibble: 14,531 × 12 #&gt; id fabricante modelo anio clase transmision traccion cilindros motor #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1833 Acura Integra 1986 Automóv… Automática 4… Delante… 4 1.6 #&gt; 2 1834 Acura Integra 1986 Automóv… Manual 5-vel… Delante… 4 1.6 #&gt; 3 3037 Acura Integra 1987 Automóv… Automática 4… Delante… 4 1.6 #&gt; 4 3038 Acura Integra 1987 Automóv… Manual 5-vel… Delante… 4 1.6 #&gt; 5 4183 Acura Integra 1988 Automóv… Automática 4… Delante… 4 1.6 #&gt; 6 4184 Acura Integra 1988 Automóv… Manual 5-vel… Delante… 4 1.6 #&gt; # … with 14,525 more rows, and 3 more variables: combustible &lt;chr&gt;, #&gt; # autopista &lt;dbl&gt;, ciudad &lt;dbl&gt; Encuentra las 48 horas (en el transcurso del año) que tengan los peores atrasos. Haz una referencia cruzada con la tabla clima. ¿Puedes observar patrones? Solución Haremos el desarrollo considerando las horas con mayor acumulación de atrasos en la salida. El otro caso queda como ejercicio. El ejercicio no pide que sean los dos peores días, sino las peores 48 horas, por lo que debemos tomar las peores horas en el transcurso de varios días. peores_horas &lt;- vuelos %&gt;% mutate(hora = salida_programada %/% 100) %&gt;% group_by(origen, anio, mes, dia, hora) %&gt;% summarise(atraso_salida = mean(atraso_salida, na.rm = TRUE)) %&gt;% ungroup() %&gt;% arrange(desc(atraso_salida)) %&gt;% slice(1:48) #&gt; `summarise()` has grouped output by &#39;origen&#39;, &#39;anio&#39;, &#39;mes&#39;, &#39;dia&#39;. You can override using the `.groups` argument. Este resultado se debe unir con la tabla clima. clima_peores_horas &lt;- semi_join(clima, peores_horas, by = c(&quot;origen&quot;, &quot;anio&quot;, &quot;mes&quot;, &quot;dia&quot;, &quot;hora&quot;)) Para el clima, nos enfocaremos en la precipitación, velocidad del viento y temperatura. Muchas de estas observaciones tienen una velocidad del viento por sobre el promedio (10 millas por hora) o lluvias. select(clima_peores_horas, temperatura, velocidad_viento, precipitacion) %&gt;% print(n = 48) #&gt; # A tibble: 48 × 3 #&gt; temperatura velocidad_viento precipitacion #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 27.0 13.8 0 #&gt; 2 28.0 19.6 0 #&gt; 3 28.9 28.8 0 #&gt; 4 33.8 9.21 0.06 #&gt; 5 34.0 8.06 0.05 #&gt; 6 80.1 8.06 0 #&gt; 7 86 13.8 0 #&gt; 8 73.4 6.90 0.08 #&gt; 9 84.0 5.75 0 #&gt; 10 78.8 18.4 0.23 #&gt; 11 53.6 0 0 #&gt; 12 60.8 31.1 0.11 #&gt; 13 55.4 17.3 0.14 #&gt; 14 53.1 9.21 0.01 #&gt; 15 55.9 11.5 0.1 #&gt; 16 55.4 8.06 0.15 #&gt; 17 57.0 29.9 0 #&gt; 18 33.8 20.7 0.02 #&gt; 19 34.0 19.6 0.01 #&gt; 20 36.0 21.9 0.01 #&gt; 21 37.9 16.1 0 #&gt; 22 32 13.8 0.12 #&gt; 23 60.1 33.4 0.14 #&gt; 24 60.8 11.5 0.02 #&gt; 25 62.1 17.3 0 #&gt; 26 66.9 10.4 0 #&gt; 27 66.9 13.8 0 #&gt; 28 79.0 10.4 0 #&gt; 29 77 16.1 0.07 #&gt; 30 75.9 13.8 0 #&gt; 31 82.4 8.06 0 #&gt; 32 86 9.21 0 #&gt; 33 80.1 9.21 0 #&gt; 34 80.6 11.5 0 #&gt; 35 78.1 6.90 0 #&gt; 36 75.2 10.4 0.01 #&gt; 37 73.9 5.75 0.03 #&gt; 38 73.9 8.06 0 #&gt; 39 75.0 4.60 0 #&gt; 40 75.0 4.60 0.01 #&gt; 41 80.1 0 0.01 #&gt; 42 80.1 0 0 #&gt; 43 77 10.4 0 #&gt; 44 82.0 10.4 0 #&gt; 45 72.0 13.8 0.3 #&gt; 46 72.0 4.60 0.03 #&gt; 47 51.1 4.60 0 #&gt; 48 54.0 6.90 0 ggplot(clima_peores_horas, aes(x = precipitacion, y = velocidad_viento, color = temperatura)) + geom_point() Para extenderse con mayor detalle en ese ejercicio, es necesario usar las herramientas del capítulo Análisis Exploratorio de Datos. ¿Qué te indica anti_join(vuelos, aeropuertos, by = c(\"destino\" = \"codigo_aeropuerto\"))? ¿Qué te indica anti_join(aeropuertos, vuelos, by = c(\"codigo_aeropuerto\" = \"destino\"))? Solución La primera expresión entrega los vuelos cuyo destino es un aeropuerto fuera de los EEUU. La segunda expresión entrega lo aeropuertos de los EEUU que no son el destino de los vuelos contenidos en los datos. Los datos contienen todos los vuelos de los aeropuertos de Nueva York, por lo que también contiene los vuelos con escalas intermedias. Puedes esperar que exista una relación implícita entre aviones y aerolíneas, dado que cada avión es operado por una única aerolínea. Confirma o descarta esta hipótesis usando las herramientas que aprendiste más arriba. Solución Veamos las combinaciones únicas de aerolínea y avión. aerolinea_avion &lt;- vuelos %&gt;% filter(!is.na(codigo_cola)) %&gt;% distinct(aerolinea, codigo_cola) Podría darse el caso en que una aerolínea vende algunos de sus aviones a otra. Estos aviones tendrán una cuenta mayor a uno en la tabla anterior. aerolinea_avion %&gt;% count(codigo_cola) %&gt;% filter(n &gt; 1) %&gt;% nrow() #&gt; [1] 17 Veamos ahora las transferencias de aviones entre aerolíneas. aviones_transferidos &lt;- aerolinea_avion %&gt;% # conservo los aviones que han volado para más de una aerolínea group_by(codigo_cola) %&gt;% filter(n() &gt; 1) %&gt;% # uno los códigos con los nombres de aerolínea left_join(aerolineas, by = &quot;aerolinea&quot;) %&gt;% arrange(aerolinea, codigo_cola) aviones_transferidos #&gt; # A tibble: 34 × 3 #&gt; # Groups: codigo_cola [17] #&gt; aerolinea codigo_cola nombre #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 9E N146PQ Endeavor Air Inc. #&gt; 2 9E N153PQ Endeavor Air Inc. #&gt; 3 9E N176PQ Endeavor Air Inc. #&gt; 4 9E N181PQ Endeavor Air Inc. #&gt; 5 9E N197PQ Endeavor Air Inc. #&gt; 6 9E N200PQ Endeavor Air Inc. #&gt; # … with 28 more rows "],["cadenas-de-caracteres.html", "14 Cadenas de caracteres 14.2 Cadenas: elementos básicos 14.3 Herramientas 14.4 Otro tipo de patrones 14.6 stringi", " 14 Cadenas de caracteres 14.2 Cadenas: elementos básicos 14.2.5 Ejercicios En ejemplos de código en los que no se utiliza stringr, verás usualmente paste() y paste0() (paste = pegar). ¿Cuál es la diferencia entre estas dos funciones? ¿A qué función de stringr son equivalentes? ¿Cómo difieren estas dos funciones respecto de su manejo de los NA? Solución paste() y paste0() se diferencian en la opción por defecto para separar los elementos que se concatenan. paste() deja un espacio; paste0() no. paste(&quot;uno&quot;, &quot;dos&quot;, &quot;tres&quot;) #&gt; [1] &quot;uno dos tres&quot; paste0(&quot;uno&quot;, &quot;dos&quot;, &quot;tres&quot;) #&gt; [1] &quot;unodostres&quot; Estas funciones son equivalentes a str_c(). Esta función por defecto no agrega un espacio entre los elementos concatenados, por lo que si queremos incluirlo es necesario explicitarlo con el argumento sep =: str_c(&quot;uno&quot;, &quot;dos&quot;, &quot;tres&quot;) #&gt; [1] &quot;unodostres&quot; str_c(&quot;uno&quot;, &quot;dos&quot;, &quot;tres&quot;, sep = &quot; &quot;) #&gt; [1] &quot;uno dos tres&quot; Si str_c() se encuentra un NA entrega como resultado NA. paste(), en cambio, paste() y paste0() lo concatenan. str_c(&quot;uno&quot;, &quot;dos&quot;, NA, sep = &quot; &quot;) #&gt; [1] NA paste(&quot;uno&quot;, &quot;dos&quot;, NA) #&gt; [1] &quot;uno dos NA&quot; Describe con tus propias palabras la diferencia entre los argumentos sep y collapse de la función str_c(). Solución sep define el caracter que se inserta entre los elementos a concatenar. collapse, por su parte, es el caracter para combinar entre los elementos a concatenar para generar un vector de extensión 1: x &lt;- c(&quot;uno&quot;, &quot;dos&quot;, &quot;tres&quot;) y &lt;- c(&quot;cuatro&quot;, &quot;cinco&quot;, &quot;seis&quot;) str_c(x, sep = &quot;-&quot;) #&gt; [1] &quot;uno&quot; &quot;dos&quot; &quot;tres&quot; str_c(x, collapse = &quot;-&quot;) #&gt; [1] &quot;uno-dos-tres&quot; str_c(x, y, sep = &quot;-&quot;) #&gt; [1] &quot;uno-cuatro&quot; &quot;dos-cinco&quot; &quot;tres-seis&quot; str_c(x, y, collapse = &quot;-&quot;) #&gt; [1] &quot;unocuatro-doscinco-tresseis&quot; Utiliza str_length() y str_sub() para extraer el caracter del medio de una cadena. ¿Qué harías si el número de caracteres es par? Solución x &lt;- c(&quot;uno&quot;, &quot;dos&quot;, &quot;tres&quot;) largo &lt;- str_length(x) mitad &lt;- ceiling(largo / 2) str_sub(x, start = mitad, end = mitad) #&gt; [1] &quot;n&quot; &quot;o&quot; &quot;r&quot; ¿Qué hace str_wrap()? (wrap = envolver) ¿Cuándo podrías querer utilizarla? Solución str_wrap() permite formatear párrafos indicando el ancho en cantidad de caracteres que queremos que tenga. El valor por defecto es 80. texto &lt;- &quot;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris in risus magna. Nulla consequat imperdiet nisl sit amet euismod. Sed nec molestie velit, non cursus neque. Suspendisse dapibus, justo at convallis pulvinar, nibh neque congue lectus, nec sollicitudin libero lacus eget nisl. Vivamus cursus turpis id quam aliquam, et fermentum tellus lacinia. Aliquam a eros nunc. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Nunc finibus auctor auctor.&quot; str_wrap(texto) #&gt; [1] &quot;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris in risus magna.\\nNulla consequat imperdiet nisl sit amet euismod. Sed nec molestie velit, non\\ncursus neque. Suspendisse dapibus, justo at convallis pulvinar, nibh neque\\ncongue lectus, nec sollicitudin libero lacus eget nisl. Vivamus cursus turpis\\nid quam aliquam, et fermentum tellus lacinia. Aliquam a eros nunc. Pellentesque\\nhabitant morbi tristique senectus et netus et malesuada fames ac turpis egestas.\\nNunc finibus auctor auctor.&quot; str_wrap(texto, width = 40) #&gt; [1] &quot;Lorem ipsum dolor sit amet, consectetur\\nadipiscing elit. Mauris in risus magna.\\nNulla consequat imperdiet nisl sit amet\\neuismod. Sed nec molestie velit, non\\ncursus neque. Suspendisse dapibus, justo\\nat convallis pulvinar, nibh neque congue\\nlectus, nec sollicitudin libero lacus\\neget nisl. Vivamus cursus turpis id quam\\naliquam, et fermentum tellus lacinia.\\nAliquam a eros nunc. Pellentesque\\nhabitant morbi tristique senectus et\\nnetus et malesuada fames ac turpis\\negestas. Nunc finibus auctor auctor.&quot; str_wrap(texto, width = 40, indent = 3) #&gt; [1] &quot; Lorem ipsum dolor sit amet,\\nconsectetur adipiscing elit. Mauris\\nin risus magna. Nulla consequat\\nimperdiet nisl sit amet euismod. Sed\\nnec molestie velit, non cursus neque.\\nSuspendisse dapibus, justo at convallis\\npulvinar, nibh neque congue lectus, nec\\nsollicitudin libero lacus eget nisl.\\nVivamus cursus turpis id quam aliquam,\\net fermentum tellus lacinia. Aliquam a\\neros nunc. Pellentesque habitant morbi\\ntristique senectus et netus et malesuada\\nfames ac turpis egestas. Nunc finibus\\nauctor auctor.&quot; ¿Qué hace str_trim()? (trim = recortar) ¿Cuál es el opuesto de str_trim()? Solución str_trim() permite eliminar espacios en blanco al inicio y al final de una cadena de caracteres: str_trim(&quot; palabra &quot;) #&gt; [1] &quot;palabra&quot; str_trim(&quot; palabra &quot;, side = &quot;left&quot;) #&gt; [1] &quot;palabra &quot; str_trim(&quot; palabra &quot;, side = &quot;right&quot;) #&gt; [1] &quot; palabra&quot; La función opuesta es str_pad(): str_pad(&quot;palabra&quot;, width = 15) #&gt; [1] &quot; palabra&quot; str_pad(&quot;palabra&quot;, width = 15, side = &quot;right&quot;) #&gt; [1] &quot;palabra &quot; str_pad(&quot;palabra&quot;, width = 15, side = &quot;both&quot;) #&gt; [1] &quot; palabra &quot; Escribe una función que convierta, por ejemplo, el vector c(\"a\", \"b\", \"c\") en la cadena a, b y c. Piensa con detención qué debería hacer dado un vector de largo 0, 1, o 2. Solución Necesitamos crear una función que tome un vector de caracteres y lo convierta en una oración enumerativa. Cuando el vector tiene un largo mayor a 2, deberá separar los elementos con coma, excepto el último, que debe separarse con “y”. Por ejemplo: a, b, c, d y e. Si su largo es 2, solo los deberá separar con “y”: a y b. Si su largo es 1, solo debería devolver ese único elemento: a. Si es de largo 0, debería devolver una cadena vacía: \"\". y &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;) str_enumeracion &lt;- function(x, delim = &quot;,&quot;) { n &lt;- length(x) if (n == 0) { &quot;&quot; } else if (n == 1) { x } else if (n == 2) { # solo separar con &quot;y&quot; str_c(x[[1]], &quot;y&quot;, x[[2]], sep = &quot; &quot;) } else { # separar con comas todos los elementos, excepto los dos último, que llevan una &quot;y&quot; str_c(c(str_c(x[seq_len(n - 2)], delim), str_c(x[[n-1]], &quot;y&quot;, x[[n]], sep = &quot; &quot;)), collapse = &quot; &quot;) } } Ahora, probemos la función con c(\"a\", \"b\", \"c\"): str_enumeracion(c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) #&gt; [1] &quot;a, b y c&quot; Veamos qué pasa cuando son menos y cuando son más elementos en la cadena: str_enumeracion(&quot;&quot;) #&gt; [1] &quot;&quot; str_enumeracion(&quot;a&quot;) #&gt; [1] &quot;a&quot; str_enumeracion(c(&quot;a&quot;, &quot;b&quot;)) #&gt; [1] &quot;a y b&quot; str_enumeracion(c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;)) #&gt; [1] &quot;a, b, c, d y e&quot; 14.2.6 Buscar coincidencia de patrones con expresiones regulares 14.2.7.1 Ejercicios Explica por qué cada una de estas cadenas no coincide con \\: \"\\\", \"\\\\\", \"\\\\\\\". Solución Como se menciona en el capítulo, tenemos que distinguir entre expresiones regulares y las cadenas de caracteres que la representan. La expresión regular que permite buscar una coincidencia con \\ es \\\\, ya que tenemos que escapar la barra invertida con otra barra invertida para que sea interpretada de manera literal. Pero para que R interprete esas dos barras como la expresión regular para coincidir con \\ en una cadena de caracteres, tenemos que escapar ambas, es decir \"\\\\\\\\\". Usar una sola barra invertida dentro de una cadena escapa el siguiente caracter. writeLines(&quot;una comilla\\&quot;&quot;) #&gt; una comilla&quot; Dos barras invertidas se interpretan como una expresión regular que escapará el siguiente caracter. x &lt;- &quot;¿aló?&quot; str_view(x, &quot;\\\\?&quot;) Tres barras invertidas en una cadena permiten escapar una barra y el siguiente caracter escapado para poder coincidir con este último: y &lt;- &quot;una barra seguida de una comilla: \\\\\\&quot;&quot; str_view(y, &quot;\\\\\\&quot;&quot;) ¿Cómo harías coincidir la secuencia \"'\\? Solución Primero, para generar esa secuencia tenemos que escapar las comillas y la barra invertida usando barras invertidas: x &lt;- &quot;\\&quot;&#39;\\\\&quot; writeLines(x) #&gt; &quot;&#39;\\ Para buscar la coincidencia: str_view(x, &quot;\\\\\\&quot;&#39;\\\\\\\\&quot;) ¿Con qué patrones coincidiría la expresión regular\\..\\..\\..? ¿Cómo la representarías en una cadena? Solución Esa expresión regular repite tres veces el mismo patrón: escapa un punto para que sea interpretado de manera literal y luego utiliza un punto para hacer coincidir cualquier caracter. Por lo tanto, coincidiría con patrones como: .a.b.c, .1.r.3, .#. .!. x &lt;- c(&quot;abc.d.e.f&quot;, &quot;.1. .3&quot;, &quot;.a.b.c&quot;, &quot;\\\\.\\\\.\\\\.&quot;) str_view(x, &quot;\\\\..\\\\..\\\\..&quot;) 14.2.8 Anclas 14.2.8.1 Ejercicios ¿Cómo harías coincidir la cadena \"$^$\" de manera literal? Solución x &lt;- &quot;$^$&quot; str_view(x, &quot;\\\\$\\\\^\\\\$&quot;) Dado el corpus de palabras comunes en datos::palabras, crea una expresión regular que busque palabras: Empiecen con “y”. Terminen con “x” Tengan una extensión de exactamente tres letras. (¡No hagas trampa usando str_length()!) Tengan siete letras o más. Dado que esta será una lista larga, podrías quere usar el argumento match en str_view() para mostrar solo las palabras que coincidan o no coincidan. Solución Las palabras que empiezan con “y” podemos buscarlas utilizando el ancla de inicio de cadena: str_view(palabras, &quot;^y&quot;, match = TRUE) Las palabras que terminen con “z” podemos buscarlas utilizando el ancla de final de cadena: str_view(palabras, &quot;z$&quot;, match = TRUE) Las que tienen una extensión de 3 letras podemos buscarlas usando tres .. Pero para que solo coincida con aquellas que tienen una extensión igual a 3, tenemos que usar anclas al inicio y final de la cadena: str_view(palabras, &quot;^...$&quot;, match = TRUE) Para buscar palabras con 8 letras o más, podemos seguir la misma lógica del caso anterior, pero esta vez sin las anclas: str_view(palabras, &quot;........&quot;, match = TRUE) 14.2.9 Clases de caracteres y alternativas 14.2.9.1 Ejercicios Crea una expresión regular que encuentre todas las palabras que: Empiecen con una vocal. Solo contengan consonantes. (Pista: piensa en cómo buscar coincidencias para “no”-vocales.) Terminen en ón, pero no en ión. Terminen con ndo o ado. Solución Para buscar todas las palabras que empiecen con vocal utilizaremos str_subset() porque son muchos resultados: str_subset(palabras, &quot;^[aáeéiíoóuúü]&quot;) #&gt; [1] &quot;a&quot; &quot;abril&quot; &quot;acción&quot; &quot;acciones&quot; #&gt; [5] &quot;acerca&quot; &quot;actitud&quot; &quot;actividad&quot; &quot;actividades&quot; #&gt; [9] &quot;acto&quot; &quot;actual&quot; &quot;acuerdo&quot; &quot;adelante&quot; #&gt; [13] &quot;además&quot; &quot;administración&quot; &quot;afirmó&quot; &quot;agua&quot; #&gt; [17] &quot;ahí&quot; &quot;ahora&quot; &quot;aire&quot; &quot;al&quot; #&gt; [21] &quot;algo&quot; &quot;alguien&quot; &quot;algún&quot; &quot;alguna&quot; #&gt; [25] &quot;algunas&quot; &quot;algunos&quot; &quot;allá&quot; &quot;allí&quot; #&gt; [29] &quot;alrededor&quot; &quot;alta&quot; &quot;alto&quot; &quot;ambiente&quot; #&gt; [33] &quot;ambos&quot; &quot;américa&quot; &quot;amigo&quot; &quot;amigos&quot; #&gt; [37] &quot;amor&quot; &quot;análisis&quot; &quot;animales&quot; &quot;ante&quot; #&gt; [41] &quot;anterior&quot; &quot;antes&quot; &quot;antonio&quot; &quot;año&quot; #&gt; [45] &quot;años&quot; &quot;aparece&quot; &quot;apenas&quot; &quot;apoyo&quot; #&gt; [49] &quot;aquel&quot; &quot;aquella&quot; &quot;aquellas&quot; &quot;aquellos&quot; #&gt; [53] &quot;aquí&quot; &quot;área&quot; &quot;argentina&quot; &quot;armas&quot; #&gt; [57] &quot;arriba&quot; &quot;arte&quot; &quot;artículo&quot; &quot;así&quot; #&gt; [61] &quot;asimismo&quot; &quot;asociación&quot; &quot;aspecto&quot; &quot;aspectos&quot; #&gt; [65] &quot;asunto&quot; &quot;atención&quot; &quot;atrás&quot; &quot;aumento&quot; #&gt; [69] &quot;aun&quot; &quot;aún&quot; &quot;aunque&quot; &quot;autor&quot; #&gt; [73] &quot;autoridades&quot; &quot;ayer&quot; &quot;ayuda&quot; &quot;e&quot; #&gt; [77] &quot;economía&quot; &quot;económica&quot; &quot;económico&quot; &quot;edad&quot; #&gt; [81] &quot;educación&quot; &quot;efecto&quot; &quot;efectos&quot; &quot;ejemplo&quot; #&gt; [85] &quot;ejército&quot; &quot;el&quot; &quot;él&quot; &quot;elecciones&quot; #&gt; [89] &quot;electoral&quot; &quot;elementos&quot; &quot;ella&quot; &quot;ellas&quot; #&gt; [93] &quot;ello&quot; &quot;ellos&quot; &quot;embargo&quot; &quot;empresa&quot; #&gt; [97] &quot;empresas&quot; &quot;en&quot; &quot;encima&quot; &quot;encontrar&quot; #&gt; [101] &quot;encuentra&quot; &quot;encuentran&quot; &quot;encuentro&quot; &quot;energía&quot; #&gt; [105] &quot;enero&quot; &quot;enfermedad&quot; &quot;entonces&quot; &quot;entrada&quot; #&gt; [109] &quot;entrar&quot; &quot;entre&quot; &quot;época&quot; &quot;equipo&quot; #&gt; [113] &quot;era&quot; &quot;eran&quot; &quot;es&quot; &quot;esa&quot; #&gt; [117] &quot;esas&quot; &quot;escuela&quot; &quot;ese&quot; &quot;esfuerzo&quot; #&gt; [121] &quot;eso&quot; &quot;esos&quot; &quot;espacio&quot; &quot;españa&quot; #&gt; [125] &quot;español&quot; &quot;española&quot; &quot;españoles&quot; &quot;especial&quot; #&gt; [129] &quot;especialmente&quot; &quot;especie&quot; &quot;espera&quot; &quot;esta&quot; #&gt; [133] &quot;está&quot; &quot;ésta&quot; &quot;estaba&quot; &quot;estaban&quot; #&gt; [137] &quot;estado&quot; &quot;estados&quot; &quot;estamos&quot; &quot;están&quot; #&gt; [141] &quot;estar&quot; &quot;estas&quot; &quot;este&quot; &quot;éste&quot; #&gt; [145] &quot;estilo&quot; &quot;esto&quot; &quot;estos&quot; &quot;estoy&quot; #&gt; [149] &quot;estructura&quot; &quot;estudio&quot; &quot;estudios&quot; &quot;estuvo&quot; #&gt; [153] &quot;etapa&quot; &quot;etc&quot; &quot;europa&quot; &quot;europea&quot; #&gt; [157] &quot;evitar&quot; &quot;ex&quot; &quot;existe&quot; &quot;existen&quot; #&gt; [161] &quot;existencia&quot; &quot;éxito&quot; &quot;experiencia&quot; &quot;explicó&quot; #&gt; [165] &quot;expresión&quot; &quot;exterior&quot; &quot;i&quot; &quot;iba&quot; #&gt; [169] &quot;idea&quot; &quot;ideas&quot; &quot;iglesia&quot; &quot;igual&quot; #&gt; [173] &quot;ii&quot; &quot;imagen&quot; &quot;imágenes&quot; &quot;importancia&quot; #&gt; [177] &quot;importante&quot; &quot;importantes&quot; &quot;imposible&quot; &quot;incluso&quot; #&gt; [181] &quot;industria&quot; &quot;información&quot; &quot;informe&quot; &quot;instituciones&quot; #&gt; [185] &quot;instituto&quot; &quot;interés&quot; &quot;intereses&quot; &quot;interior&quot; #&gt; [189] &quot;internacional&quot; &quot;investigación&quot; &quot;ir&quot; &quot;izquierda&quot; #&gt; [193] &quot;o&quot; &quot;objetivo&quot; &quot;objeto&quot; &quot;obra&quot; #&gt; [197] &quot;obras&quot; &quot;obstante&quot; &quot;ocasión&quot; &quot;ocasiones&quot; #&gt; [201] &quot;ocho&quot; &quot;octubre&quot; &quot;oficial&quot; &quot;ojos&quot; #&gt; [205] &quot;operación&quot; &quot;opinión&quot; &quot;oposición&quot; &quot;orden&quot; #&gt; [209] &quot;organización&quot; &quot;origen&quot; &quot;oro&quot; &quot;otra&quot; #&gt; [213] &quot;otras&quot; &quot;otro&quot; &quot;otros&quot; &quot;u&quot; #&gt; [217] &quot;última&quot; &quot;último&quot; &quot;últimos&quot; &quot;un&quot; #&gt; [221] &quot;una&quot; &quot;unas&quot; &quot;única&quot; &quot;único&quot; #&gt; [225] &quot;unidad&quot; &quot;unidos&quot; &quot;unión&quot; &quot;universidad&quot; #&gt; [229] &quot;uno&quot; &quot;unos&quot; &quot;uso&quot; &quot;usted&quot; Para buscar palabras que solo tienen consonantes buscamos no-vocales que se repitan una o más veces (+) y anclamos el inicio y fin de la cadena. datos::palabras incluye algunas abreviaciones (por ejemplo, pp = páginas), por lo que junto con “y” es lo único que encontraremos. str_view(palabras, &quot;^[^aáeéiíoóuúü]+$&quot;, match = TRUE) Palabras que terminan en ón, pero no en ión. str_view(palabras, &quot;[^i]ón$&quot;, match = TRUE) Palabras que terminan con ndo o ado: str_view(palabras, &quot;(n|a)do&quot;, match = TRUE) ¿Siempre a una “q” la sigue una “u”? Solución Podemos buscar las “q” y ver qué las sigue: str_subset(palabras, &quot;q.&quot;) #&gt; [1] &quot;aquel&quot; &quot;aquella&quot; &quot;aquellas&quot; &quot;aquellos&quot; &quot;aquí&quot; &quot;aunque&quot; #&gt; [7] &quot;cualquier&quot; &quot;equipo&quot; &quot;izquierda&quot; &quot;pequeña&quot; &quot;pequeño&quot; &quot;porque&quot; #&gt; [13] &quot;que&quot; &quot;qué&quot; &quot;queda&quot; &quot;quedó&quot; &quot;quería&quot; &quot;quien&quot; #&gt; [19] &quot;quién&quot; &quot;quienes&quot; &quot;quiere&quot; &quot;quiero&quot; &quot;quizá&quot; &quot;siquiera&quot; O podemos buscar al revés: si a alguna “q” la sigue algo que no sea una “u”: str_subset(palabras, &quot;q[^u]&quot;) #&gt; character(0) Escribe una expresión regular que permita buscar un verbo que haya sido escrito usando voseo en segunda persona plural (por ejemplo, queréis en vez de quieren). Solución segunda_persona &lt;- c(&quot;queréis&quot;, &quot;quieren&quot;) str_view(segunda_persona, &quot;éis$&quot;, match = TRUE) Crea una expresión regular que coincida con la forma en que habitualmente se escriben los números de teléfono en tu país. Solución La respuesta varía según país y a veces dentro de un mismo país no siempre se usa un mismo formato. Para este ejercicio trataremos de encontrar este patrón: “(XX) XXX XX XX”, es decir, un código de ciudad entre paréntesis y el número separado en bloques de 3-2-2 dígitos con un espacio entre medio. Los dígitos pueden representarse como [0-9] o \\\\d telefonos &lt;- c(&quot;(32) 281 91 76&quot;, &quot;(32)2819176&quot;, &quot;(32)281 9176&quot;) str_view(telefonos, &quot;\\\\(\\\\d\\\\d\\\\) \\\\d\\\\d\\\\d \\\\d\\\\d \\\\d\\\\d&quot;) Este código podría simplificarse si es que utilizáramos algún modificador que nos permita controlar la repetición de patrones. En la próxima sesión se aborda este tema. En inglés existe una regla que dice que la letra i va siempre antes de la e, excepto cuando está después de una c\". Verifica empíricamente esta regla utilizando las palabras contenidas en stringr::words. Solución Para comprobar esta regla primero podríamos buscar si existe el patrón: cie str_subset(words, &quot;cie&quot;) #&gt; [1] &quot;science&quot; &quot;society&quot; ¡Hay dos palabras que indicarían que la excepción no se cumple siempre! ¿Y hay casos en los que la letra i va después de la e sin que esté precedida de una c? str_subset(words, &quot;[^c]ei&quot;) #&gt; [1] &quot;weigh&quot; Hay uno. Puede que estas sean excepciones, así que para ver qué tan frecuente es el patrón que indica la regla, busquemos las palabras en que sí se cumple str_subset(words, &quot;[^c]ie|cei&quot;) #&gt; [1] &quot;achieve&quot; &quot;believe&quot; &quot;brief&quot; &quot;client&quot; &quot;die&quot; #&gt; [6] &quot;experience&quot; &quot;field&quot; &quot;friend&quot; &quot;lie&quot; &quot;piece&quot; #&gt; [11] &quot;quiet&quot; &quot;receive&quot; &quot;tie&quot; &quot;view&quot; Son muchas más. 14.2.10 Repetición 14.2.10.1 Ejercicios Describe los equivalentes de ?, +, * en el formato {m,n}. Solución ? = {0,1} = una sola coincidencia + = {1,} = uno o más coincidencias * = {0,}= cero o más coincidencias Describe en palabras con qué coincidiría cada una de estas expresiones regulares: (lee con atención para ver si estamos utilizando una expresión regular o una cadena que define una expresión regular.) ^.*$ \"\\\\{.+\\\\}\" \\d{4}-\\d{2}-\\d{2} \"\\\\\\\\{4}\" Solución ^.*$: es una expresión regular que coincidiría con cualquier cadena de caracteres, incluso si no tiene nada en su interior. La expresión regular buscar cualquier caracter (.) que aparezca 0 o más veces (*) al inicio (^) o al final $ de una cadena de caracteres: cadena &lt;- c(&quot;123&quot;, &quot;una palabra&quot;, &quot;estas son cuatro palabras&quot;, &quot; &quot;, &quot;&quot;) str_match(cadena, &quot;^.*$&quot;) #&gt; [,1] #&gt; [1,] &quot;123&quot; #&gt; [2,] &quot;una palabra&quot; #&gt; [3,] &quot;estas son cuatro palabras&quot; #&gt; [4,] &quot; &quot; #&gt; [5,] &quot;&quot; \"\\\\{.+\\\\}\": es la cadena que representa una expresión regular coincidiría con {} y lo que tengan dentro, siempre que tenga al menos un caracter (.+): cadena &lt;- c(&quot;uno {dos} tres&quot;, &quot;uno {} tres&quot;, &quot;uno {2} tres&quot;) str_view(cadena, &quot;\\\\{.+\\\\}&quot;) La expresión regular \\d{4}-\\d{2}-\\d{2} coincide con secuencias de 4, 2 y 2 dígitos separados por un guión. numeros &lt;- c(&quot;4444-22-22&quot;, &quot;333-22-22&quot;, &quot;88888888&quot;) str_view(numeros, &quot;\\\\d{4}-\\\\d{2}-\\\\d{2}&quot;) La cadena “\\\\{4}” coincidiría con una barra invertida repetida 4 veces: barras &lt;- c(&quot;\\\\&quot;, &quot;\\\\\\\\&quot;, &quot;\\\\\\\\\\\\&quot;, &quot;\\\\\\\\\\\\\\\\&quot;) str_view(barras, &quot;\\\\\\\\{4}&quot;) Crea expresiones regulares para buscar todas las palabras que: Empiecen con dos consonantes. Tengan tres o más vocales seguidas. Tengan tres o más pares de vocal-consonante seguidos. Solución Para buscar palabras que empiecen con dos consonantes buscaremos la repetición de no-vocales al inicio de una cadena: str_view(palabras, &quot;^[^aáeéiíoóuúü]{2}&quot;, match = TRUE) Palabras con tres o más vocales seguidas str_view(palabras, &quot;[aáeéiíoóuúü]{3,}&quot;, match = TRUE) Palabras que tengan tres o más pares de vocal-consonante seguidos: str_view(palabras, &quot;([aáeéiíoóuúü][^aáeéiíoóuúü]){3,}&quot;, match = TRUE) 14.2.11 Agrupamiento y referencias previas 14.2.11.1 Ejercicios Describe en palabras con qué coinciden estas expresiones: (.)\\1\\1 \"(.)(.)\\\\2\\\\1\" (..)\\1 \"(.).\\\\1.\\\\1\" \"(.)(.)(.).*\\\\3\\\\2\\\\1\" Solución La expresión regular (.)\\1\\1 coincide con cualquier caracter repetido tres veces seguidas. str_view(c(&quot;a&quot;, &quot;aa&quot;, &quot;aaa&quot;, &quot;aaaa&quot;), &quot;(.)\\\\1\\\\1&quot;) La cadena \"(.)(.)\\\\2\\\\1\" coincide con los dos caracteres capturados seguidos de los mismos dos caracteres pero en orden inverso: str_view(c(&quot;abba&quot;, &quot;abab&quot;), &quot;(.)(.)\\\\2\\\\1&quot;) La expresión regular (..)\\1 coincide con un par de letras que se repite dos veces: str_view(c(&quot;abba&quot;, &quot;abab&quot;), &quot;(..)\\\\1&quot;) La cadena \"(.).\\\\1.\\\\1\" coicide con la secuencia: caracter capturado, otro caracter, caracter capturado, otro caracter, caracter capturado: str_view(c(&quot;babab&quot;, &quot;babeb&quot;, &quot;abab&quot;), &quot;(.).\\\\1.\\\\1&quot;) La cadena \"(.)(.)(.).*\\\\3\\\\2\\\\1\" coincide con los tres caracteres capturados, cero o más de otros caracteres y luego los tres caracteres capturados en orden inverso: str_view(c(&quot;abcdefgcba&quot;, &quot;abccba&quot;, &quot;abcabc&quot;), &quot;(.)(.)(.).*\\\\3\\\\2\\\\1&quot;) Construye una expresión regular que coincida con palabras que: Empiecen y terminen con el mismo caracter. Contengan un par de letras repetido (p. ej. “nacional” tiene “na” repetidos dos veces.) Contengan una letra repetida en al menos tres lugares (p. ej. “característica” tiene tres “a”.) Solución Para buscar palabras que empiecen y terminen con el mismo caracter: str_subset(palabras, &quot;^(.).*\\\\1$&quot;) #&gt; [1] &quot;acerca&quot; &quot;agua&quot; &quot;ahora&quot; &quot;alguna&quot; #&gt; [5] &quot;alta&quot; &quot;américa&quot; &quot;aquella&quot; &quot;argentina&quot; #&gt; [9] &quot;arriba&quot; &quot;ayuda&quot; &quot;entre&quot; &quot;ese&quot; #&gt; [13] &quot;especialmente&quot; &quot;especie&quot; &quot;este&quot; &quot;existe&quot; #&gt; [17] &quot;ii&quot; &quot;local&quot; &quot;ningún&quot; &quot;objetivo&quot; #&gt; [21] &quot;objeto&quot; &quot;ocho&quot; &quot;oro&quot; &quot;otro&quot; #&gt; [25] &quot;pp&quot; &quot;realizar&quot; &quot;sectores&quot; &quot;seis&quot; #&gt; [29] &quot;semanas&quot; &quot;servicios&quot; &quot;siguientes&quot; &quot;sistemas&quot; #&gt; [33] &quot;sociales&quot; &quot;somos&quot; &quot;sus&quot; Si bien el código permite encontrar lo que buscábamos, lo cierto es que ese patrón busca cadenas de caracteres que empiecen y terminen con el mismo caracter, no necesariamente una letra. Es decir, también coincidería con #455#. Si quisiéramos que solo encontrara letras: str_subset(palabras, &quot;^([:alpha:]).*\\\\1$&quot;) #&gt; [1] &quot;acerca&quot; &quot;agua&quot; &quot;ahora&quot; &quot;alguna&quot; #&gt; [5] &quot;alta&quot; &quot;américa&quot; &quot;aquella&quot; &quot;argentina&quot; #&gt; [9] &quot;arriba&quot; &quot;ayuda&quot; &quot;entre&quot; &quot;ese&quot; #&gt; [13] &quot;especialmente&quot; &quot;especie&quot; &quot;este&quot; &quot;existe&quot; #&gt; [17] &quot;ii&quot; &quot;local&quot; &quot;ningún&quot; &quot;objetivo&quot; #&gt; [21] &quot;objeto&quot; &quot;ocho&quot; &quot;oro&quot; &quot;otro&quot; #&gt; [25] &quot;pp&quot; &quot;realizar&quot; &quot;sectores&quot; &quot;seis&quot; #&gt; [29] &quot;semanas&quot; &quot;servicios&quot; &quot;siguientes&quot; &quot;sistemas&quot; #&gt; [33] &quot;sociales&quot; &quot;somos&quot; &quot;sus&quot; Palabras que contienen un par de letras repetido: str_subset(palabras, &quot;([:alpha:][:alpha:]).*\\\\1&quot;) #&gt; [1] &quot;alrededor&quot; &quot;análisis&quot; &quot;asociación&quot; &quot;características&quot; #&gt; [5] &quot;ciencia&quot; &quot;conciencia&quot; &quot;condiciones&quot; &quot;crisis&quot; #&gt; [9] &quot;desde&quot; &quot;económico&quot; &quot;encuentra&quot; &quot;encuentran&quot; #&gt; [13] &quot;encuentro&quot; &quot;españoles&quot; &quot;intereses&quot; &quot;internacional&quot; #&gt; [17] &quot;meses&quot; &quot;nacional&quot; &quot;nosotros&quot; &quot;participación&quot; #&gt; [21] &quot;particular&quot; &quot;respuesta&quot; &quot;tercera&quot; &quot;tienen&quot; #&gt; [25] &quot;vivir&quot; Palabras que contienen una letra repetida en al menos tres lugares: str_subset(palabras, &quot;([:alpha:]).*\\\\1.*\\\\1&quot;) #&gt; [1] &quot;administración&quot; &quot;campaña&quot; &quot;capacidad&quot; &quot;características&quot; #&gt; [5] &quot;carrera&quot; &quot;comunicación&quot; &quot;conciencia&quot; &quot;conocimiento&quot; #&gt; [9] &quot;consecuencia&quot; &quot;construcción&quot; &quot;diferentes&quot; &quot;elecciones&quot; #&gt; [13] &quot;elementos&quot; &quot;encuentran&quot; &quot;enfermedad&quot; &quot;especialmente&quot; #&gt; [17] &quot;especie&quot; &quot;experiencia&quot; &quot;generales&quot; &quot;instituciones&quot; #&gt; [21] &quot;instituto&quot; &quot;intereses&quot; &quot;internacional&quot; &quot;investigación&quot; #&gt; [25] &quot;mañana&quot; &quot;ministerio&quot; &quot;naturaleza&quot; &quot;ningún&quot; #&gt; [29] &quot;ninguna&quot; &quot;nosotros&quot; &quot;palabra&quot; &quot;palabras&quot; #&gt; [33] &quot;participación&quot; &quot;posibilidad&quot; &quot;posibilidades&quot; &quot;precisamente&quot; #&gt; [37] &quot;presente&quot; &quot;presidente&quot; &quot;principio&quot; &quot;principios&quot; #&gt; [41] &quot;septiembre&quot; &quot;sistemas&quot; &quot;trabajadores&quot; &quot;trabajar&quot; #&gt; [45] &quot;tratamiento&quot; 14.3 Herramientas 14.3.2 Ejercicios Para cada uno de los siguientes desafíos, intenta buscar una solución utilizando tanto una expresión regular simple como una combinación de múltiples llamadas a str_detect(). Encuentra todas las palabras que empiezan o terminan con y. Encuentra todas las palabras que empiezan con una vocal y terminan con una consonante. ¿Existen palabras que tengan todas las vocales? Solución Para encontrar todas las palabras que empiezan o terminan con y con una sola expresión regular: str_view(palabras, &quot;^y|y$&quot;, match = TRUE) Con múltiples llamadas a str_detect(): palabras[str_detect(palabras, &quot;^y&quot;) | str_detect(palabras, &quot;y$&quot;)] #&gt; [1] &quot;estoy&quot; &quot;hay&quot; &quot;hoy&quot; &quot;ley&quot; &quot;muy&quot; &quot;rey&quot; &quot;soy&quot; &quot;voy&quot; &quot;y&quot; #&gt; [10] &quot;ya&quot; &quot;yo&quot; Para encontrar todas las palabras que empiezan con una vocal y terminan con una consonante con una expresión regular: palabras %&gt;% str_subset(&quot;^[aáeéiíoóuúü].*[^aáeéiíoóuúü]$&quot;) %&gt;% head(n = 10) # son muchas así que miraremos las 10 primeras #&gt; [1] &quot;abril&quot; &quot;acción&quot; &quot;acciones&quot; &quot;actitud&quot; #&gt; [5] &quot;actividad&quot; &quot;actividades&quot; &quot;actual&quot; &quot;además&quot; #&gt; [9] &quot;administración&quot; &quot;al&quot; Con múltiples llamadas a str_detect(): palabras[str_detect(palabras, &quot;^[aáeéiíoóuú]&quot;) &amp; str_detect(palabras, &quot;[^aáeéiíoóuú]$&quot;)][1:10] #&gt; [1] &quot;abril&quot; &quot;acción&quot; &quot;acciones&quot; &quot;actitud&quot; #&gt; [5] &quot;actividad&quot; &quot;actividades&quot; &quot;actual&quot; &quot;además&quot; #&gt; [9] &quot;administración&quot; &quot;al&quot; ¿Existen palabras que tengan todas las vocales? Para resolver esto con una sola expresión regular: palabras[str_detect(palabras, &quot;(?=.*(a|á))(?=.*(e|é))(?=.*(i|í))(?=.*(o|o))(?=.*(u|ú|ü))&quot;)] #&gt; [1] &quot;autoridades&quot; &quot;consecuencia&quot; Con varias llamas a str_detect() palabras[str_detect(palabras, &quot;a|á&quot;) &amp; str_detect(palabras, &quot;e|é&quot;) &amp; str_detect(palabras, &quot;i|í&quot;) &amp; str_detect(palabras, &quot;o|o&quot;) &amp; str_detect(palabras, &quot;u|ú|ü&quot;)] #&gt; [1] &quot;autoridades&quot; &quot;consecuencia&quot; ¿Qué palabra tiene el mayor número de vocales? ¿Qué palabra tiene la mayor proporción de vocales? (Pista: ¿cuál es el denominador?) Solución Para responder esta pregunta tenemos que contar la cantidad de vocales y además calcular su proporción respecto del total de letras de la palabra. Hay varias formas de resolver esto. La que usaremos acá será crear un tibble y usar las funciones de stringr dentro de mutate: df &lt;- palabras %&gt;% tibble(palabra = .) %&gt;% mutate(largo = str_length(palabra)) %&gt;% mutate(vocales = str_count(palabra, &quot;[aáeéiíoóuúü]&quot;)) %&gt;% mutate(prop_vocales = vocales / largo) Ahora podemos responder las preguntas. Las palabras con más vocales en este set de datos tienen 6 en total. Son 15: top_n(df, 1, vocales) #&gt; # A tibble: 15 × 4 #&gt; palabra largo vocales prop_vocales #&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 administración 14 6 0.429 #&gt; 2 asociación 10 6 0.6 #&gt; 3 autoridades 11 6 0.545 #&gt; 4 características 15 6 0.4 #&gt; 5 comunicación 12 6 0.5 #&gt; 6 conocimiento 12 6 0.5 #&gt; # … with 9 more rows Hay palabras solo compuestas por vocales. Cuatro son efectivamente palabras (una preposición y tres conjunciones) y dos son vocales que se usan para numerar (“i”, “ii”): top_n(df, 1, prop_vocales) #&gt; # A tibble: 6 × 4 #&gt; palabra largo vocales prop_vocales #&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 a 1 1 1 #&gt; 2 e 1 1 1 #&gt; 3 i 1 1 1 #&gt; 4 ii 2 2 1 #&gt; 5 o 1 1 1 #&gt; 6 u 1 1 1 14.3.3 Extraer coincidencias 14.3.3.1 Ejercicios Te habrás dado cuenta que en el ejemplo anterior la expresión regular que utilizamos también devolvió como resultado “arrojo” y “azulejos”, que no son nombres de colores. Modifica la expresión regular para resolver ese problema. Solución En principio, para asegurarnos que solo busque nuestro patrón de manera exacta podríamos indicar límites de palabra con \\\\b. Con el inicio no tendríamos problemas y eso eliminaría “arrojo”. Sin embargo, si ponemos el límite de final de palabra no solo eliminaría “azulejo” sino también “verdes”. Para este ejemplo en particular no importa porque estamos buscando más de una coincidencia por cadena y “verdes” está en la misma cadena que azulajos (es decir, al eliminar esta última palabra queda un solo color en la cadena y por tanto que no responde a lo que estamos buscando). Pero si hubiese otro caso de color en plural sí tendríamos que modificar nuestro patrón. Una manera de resolver esto sería que nuestro patrón busque también las versiones en plural de los colores que indicamos. Y para hacerlo mejor aún, que busque también cuando el adjetivo sea femenino o masculino: # agregamos la opción de plural colores &lt;- c(&quot;roj(a|o)s*&quot;, &quot;amarill(a|o)s*&quot;, &quot;verde&quot;, &quot;azul(es)*&quot;, &quot;marr(o|ó)n&quot;) # agregamos límites de palabra al inicio y al final coincidencia_color &lt;- str_c(&quot;\\\\b(&quot;, str_c(colores, collapse = &quot;|&quot;), &quot;)\\\\b&quot;) tiene_color &lt;- str_subset(oraciones, coincidencia_color) mas &lt;- oraciones[str_count(oraciones, coincidencia_color) &gt; 1] str_view_all(mas, coincidencia_color) # chequear que encuentra también colores en plural y adjetivos femeninos en otros ejemplos: otras_oraciones 1] #> [1] \"amarillas y rojas\" \"rojas y azules\" De datos::oraciones extrae: La primera palabra de cada oración. Todas las palabras que terminen en ción. Todos los plurales. Solución Como cada oración es una cadena, podemos extraer la primera palabra de cada oración con \\\\w, que busca cualquier caracter de palabra con un ancla al inicio y un límite de palabra al final. Otra forma de buscar solo caracteres de palabras es con [:alpha:]: str_extract(oraciones, &quot;^(\\\\w+)\\\\b&quot;) #&gt; [1] &quot;Las&quot; &quot;La&quot; &quot;El&quot; &quot;Agrega&quot; &quot;Nueve&quot; #&gt; [6] &quot;Pega&quot; &quot;Instalaron&quot; &quot;Si&quot; &quot;Dos&quot; &quot;El&quot; #&gt; [11] &quot;Una&quot; &quot;Las&quot; &quot;Él&quot; &quot;La&quot; &quot;Había&quot; #&gt; [16] &quot;El&quot; &quot;El&quot; &quot;El&quot; &quot;Podían&quot; &quot;El&quot; #&gt; [21] &quot;Una&quot; &quot;Los&quot; &quot;El&quot; &quot;La&quot; &quot;El&quot; #&gt; [26] &quot;La&quot; &quot;El&quot; &quot;Recuéstate&quot; &quot;El&quot; &quot;Marca&quot; #&gt; [31] &quot;El&quot; &quot;La&quot; &quot;Ofreció&quot; &quot;Un&quot; &quot;El&quot; #&gt; [36] &quot;Una&quot; &quot;Dibuja&quot; &quot;La&quot; &quot;Pinta&quot; &quot;Despiértate&quot; #&gt; [41] &quot;La&quot; &quot;Puso&quot; &quot;El&quot; &quot;Corta&quot; &quot;Llovieron&quot; #&gt; [46] &quot;El&quot; &quot;El&quot; &quot;La&quot; &quot;El&quot; &quot;Cada&quot; str_extract(oraciones, &quot;^([:alpha:]+)\\\\b&quot;) #&gt; [1] &quot;Las&quot; &quot;La&quot; &quot;El&quot; &quot;Agrega&quot; &quot;Nueve&quot; #&gt; [6] &quot;Pega&quot; &quot;Instalaron&quot; &quot;Si&quot; &quot;Dos&quot; &quot;El&quot; #&gt; [11] &quot;Una&quot; &quot;Las&quot; &quot;Él&quot; &quot;La&quot; &quot;Había&quot; #&gt; [16] &quot;El&quot; &quot;El&quot; &quot;El&quot; &quot;Podían&quot; &quot;El&quot; #&gt; [21] &quot;Una&quot; &quot;Los&quot; &quot;El&quot; &quot;La&quot; &quot;El&quot; #&gt; [26] &quot;La&quot; &quot;El&quot; &quot;Recuéstate&quot; &quot;El&quot; &quot;Marca&quot; #&gt; [31] &quot;El&quot; &quot;La&quot; &quot;Ofreció&quot; &quot;Un&quot; &quot;El&quot; #&gt; [36] &quot;Una&quot; &quot;Dibuja&quot; &quot;La&quot; &quot;Pinta&quot; &quot;Despiértate&quot; #&gt; [41] &quot;La&quot; &quot;Puso&quot; &quot;El&quot; &quot;Corta&quot; &quot;Llovieron&quot; #&gt; [46] &quot;El&quot; &quot;El&quot; &quot;La&quot; &quot;El&quot; &quot;Cada&quot; Es posible encontrar también el siguiente patrón para representar caracteres de palabras: [a-z] o [A-Za-z] (para que busque mayúsculas también)- Sin embargo, hay que tener cuidado con su utilización en español, ya que no reconoce tildes. En este mismo ejemplo, nos devuelve NA en todas las palabras en las que hay tildes: str_extract(oraciones, &quot;^([A-Za-z]+)\\\\b&quot;) #&gt; [1] &quot;Las&quot; &quot;La&quot; &quot;El&quot; &quot;Agrega&quot; &quot;Nueve&quot; #&gt; [6] &quot;Pega&quot; &quot;Instalaron&quot; &quot;Si&quot; &quot;Dos&quot; &quot;El&quot; #&gt; [11] &quot;Una&quot; &quot;Las&quot; NA &quot;La&quot; NA #&gt; [16] &quot;El&quot; &quot;El&quot; &quot;El&quot; NA &quot;El&quot; #&gt; [21] &quot;Una&quot; &quot;Los&quot; &quot;El&quot; &quot;La&quot; &quot;El&quot; #&gt; [26] &quot;La&quot; &quot;El&quot; NA &quot;El&quot; &quot;Marca&quot; #&gt; [31] &quot;El&quot; &quot;La&quot; NA &quot;Un&quot; &quot;El&quot; #&gt; [36] &quot;Una&quot; &quot;Dibuja&quot; &quot;La&quot; &quot;Pinta&quot; NA #&gt; [41] &quot;La&quot; &quot;Puso&quot; &quot;El&quot; &quot;Corta&quot; &quot;Llovieron&quot; #&gt; [46] &quot;El&quot; &quot;El&quot; &quot;La&quot; &quot;El&quot; &quot;Cada&quot; 14.3.4 Coincidencias agrupadas 14.3.4.1 Ejercicios Busca en datos::oraciones todas las palabras que vengan después de un “número”, como “un(o|a)”, “dos”, “tres”, etc. Extrae tanto el número como la palabra. Solución Responderemos esta pregunta para números del 1 al 10 utilizando las dos formas recién vistas: str_match() y tidyr::extract(): numero_palabra &lt;- &quot;(una*o*|dos|tres|cuatro|cinco|seis|siete|ocho|nueve|diez) ([^ ]+)&quot; str_match(oraciones, numero_palabra) #&gt; [,1] [,2] [,3] #&gt; [1,] NA NA NA #&gt; [2,] NA NA NA #&gt; [3,] NA NA NA #&gt; [4,] NA NA NA #&gt; [5,] &quot;dos para&quot; &quot;dos&quot; &quot;para&quot; #&gt; [6,] NA NA NA #&gt; [7,] NA NA NA #&gt; [8,] NA NA NA #&gt; [9,] NA NA NA #&gt; [10,] NA NA NA #&gt; [11,] NA NA NA #&gt; [12,] NA NA NA #&gt; [13,] NA NA NA #&gt; [14,] NA NA NA #&gt; [15,] NA NA NA #&gt; [16,] NA NA NA #&gt; [17,] NA NA NA #&gt; [18,] &quot;dos pastillas.&quot; &quot;dos&quot; &quot;pastillas.&quot; #&gt; [19,] NA NA NA #&gt; [20,] NA NA NA #&gt; [21,] &quot;una ave&quot; &quot;una&quot; &quot;ave&quot; #&gt; [22,] NA NA NA #&gt; [23,] NA NA NA #&gt; [24,] &quot;una llama&quot; &quot;una&quot; &quot;llama&quot; #&gt; [25,] NA NA NA #&gt; [26,] NA NA NA #&gt; [27,] &quot;diez años.&quot; &quot;diez&quot; &quot;años.&quot; #&gt; [28,] NA NA NA #&gt; [29,] NA NA NA #&gt; [30,] &quot;un cartel&quot; &quot;un&quot; &quot;cartel&quot; #&gt; [31,] NA NA NA #&gt; [32,] NA NA NA #&gt; [33,] &quot;tres gráficos.&quot; &quot;tres&quot; &quot;gráficos.&quot; #&gt; [34,] &quot;un suéter&quot; &quot;un&quot; &quot;suéter&quot; #&gt; [35,] NA NA NA #&gt; [36,] NA NA NA #&gt; [37,] NA NA NA #&gt; [38,] NA NA NA #&gt; [39,] NA NA NA #&gt; [40,] NA NA NA #&gt; [41,] NA NA NA #&gt; [42,] NA NA NA #&gt; [43,] NA NA NA #&gt; [44,] &quot;una delgada&quot; &quot;una&quot; &quot;delgada&quot; #&gt; [45,] &quot;dos lados.&quot; &quot;dos&quot; &quot;lados.&quot; #&gt; [46,] NA NA NA #&gt; [47,] NA NA NA #&gt; [48,] NA NA NA #&gt; [49,] NA NA NA #&gt; [50,] NA NA NA tibble(oracion = oraciones) %&gt;% tidyr::extract( oracion, c(&quot;numero&quot;, &quot;palabra&quot;), numero_palabra, remove = FALSE ) %&gt;% filter(!is.na(palabra)) # solo ver las filas con resultados #&gt; # A tibble: 10 × 3 #&gt; oracion numero palabra #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Nueve hombres fueron contratados para excavar las ruinas. dos para #&gt; 2 El médico lo curó con estas dos pastillas. dos pastillas. #&gt; 3 Una grulla azul es una ave zancuda y alta. una ave #&gt; 4 La lámpara brillaba con una llama verde y continua. una llama #&gt; 5 El lazo púrpura tenía diez años. diez años. #&gt; 6 Marca el lugar con un cartel pintado de rojo. un cartel #&gt; # … with 4 more rows Para definir lo que es una palabra utilizamos la misma heurística propuesta en esta sección del libro, es decir, todo lo que no es un espacio. Sin embargo, esto hace que se extraigan también los puntos. Una manera de evitarlo es utilizar \\\\w: numero_palabra2 &lt;- &quot;(una*o*|dos|tres|cuatro|cinco|seis|siete|ocho|nueve|diez) (\\\\w+)&quot; tibble(oracion = oraciones) %&gt;% tidyr::extract( oracion, c(&quot;numero&quot;, &quot;palabra&quot;), numero_palabra2, remove = FALSE ) %&gt;% filter(!is.na(palabra)) # solo ver las filas con resultados #&gt; # A tibble: 10 × 3 #&gt; oracion numero palabra #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Nueve hombres fueron contratados para excavar las ruinas. dos para #&gt; 2 El médico lo curó con estas dos pastillas. dos pastillas #&gt; 3 Una grulla azul es una ave zancuda y alta. una ave #&gt; 4 La lámpara brillaba con una llama verde y continua. una llama #&gt; 5 El lazo púrpura tenía diez años. diez a #&gt; 6 Marca el lugar con un cartel pintado de rojo. un cartel #&gt; # … with 4 more rows En español a veces se utiliza el guión para unir adjetivos, establecer relaciones entre conceptos o para unir gentilicios (p. ej., teórico-práctico, precio-calidad, franco-porteño). ¿Cómo podrías encontrar esas palabras y separar lo que viene antes y después del guión? Solución Para separar las palabras podemos utilizar la función str_split() compuestas &lt;- c(&quot;teórico-práctico&quot;, &quot;precio-calidad&quot;, &quot;franco-porteño&quot;) tiene_guion &lt;- &quot;\\\\w+-\\\\w+&quot; str_extract(compuestas, tiene_guion) %&gt;% str_split(&quot;-&quot;) #&gt; [[1]] #&gt; [1] &quot;teórico&quot; &quot;práctico&quot; #&gt; #&gt; [[2]] #&gt; [1] &quot;precio&quot; &quot;calidad&quot; #&gt; #&gt; [[3]] #&gt; [1] &quot;franco&quot; &quot;porteño&quot; Si quisiéramos hacer esto mismo en el contexto de un data frame, podríamos utilizar la función tidyr::separate: tibble(palabras_compuestas = compuestas) %&gt;% tidyr::separate(palabras_compuestas, c(&quot;palabra1&quot;, &quot;palabra2&quot;), sep = &quot;-&quot;, remove = FALSE) # para no eliminar la columna original #&gt; # A tibble: 3 × 3 #&gt; palabras_compuestas palabra1 palabra2 #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 teórico-práctico teórico práctico #&gt; 2 precio-calidad precio calidad #&gt; 3 franco-porteño franco porteño 14.3.5 Remplazar coincidencias 14.3.5.1 Ejercicios Remplaza en una cadena todas las barras por barras invertidas. Solución barras &lt;- &quot;una /, dos barras //, tres ///&quot; str_replace_all(barras, &quot;/&quot;, &quot;\\\\\\\\&quot;) %&gt;% writeLines() #&gt; una \\, dos barras \\\\, tres \\\\\\ Implementa una versón simple de str_to_lower() (a minúsculas) usando replace_all(). Solución Una manera sería buscar todas las mayúsculas y remplazarlas por su versión en minúcula. # Crear un vector con todos los remplazos: a_minuscula &lt;- c( &quot;A&quot; = &quot;a&quot;, &quot;Á&quot; = &quot;á&quot;, &quot;B&quot; = &quot;b&quot;, &quot;C&quot; = &quot;c&quot;, &quot;D&quot; = &quot;d&quot;, &quot;E&quot; = &quot;e&quot;, &quot;É&quot; = &quot;é&quot;,&quot;F&quot; = &quot;f&quot;, &quot;G&quot; = &quot;g&quot;, &quot;H&quot; = &quot;h&quot;, &quot;I&quot; = &quot;i&quot;, &quot;Í&quot; = &quot;í&quot;, &quot;J&quot; = &quot;j&quot;, &quot;K&quot; = &quot;k&quot;, &quot;L&quot; = &quot;l&quot;, &quot;M&quot; = &quot;m&quot;, &quot;N&quot; = &quot;n&quot;, &quot;Ñ&quot; = &quot;ñ&quot;,&quot;O&quot; = &quot;o&quot;, &quot;Ó&quot; = &quot;ó&quot;, &quot;P&quot; = &quot;p&quot;, &quot;Q&quot; = &quot;q&quot;, &quot;R&quot; = &quot;r&quot;, &quot;S&quot; = &quot;s&quot;, &quot;T&quot; = &quot;t&quot;, &quot;U&quot; = &quot;u&quot;, &quot;Ú&quot; = &quot;ú&quot;,&quot;V&quot; = &quot;v&quot;, &quot;W&quot; = &quot;w&quot;, &quot;X&quot; = &quot;x&quot;, &quot;Y&quot; = &quot;y&quot;, &quot;Z&quot; = &quot;z&quot;) mayusculas &lt;- c(&quot;Hola&quot;, &quot;Buenos días&quot;, &quot;Adiós&quot;) str_replace_all(mayusculas, pattern = a_minuscula) #&gt; [1] &quot;hola&quot; &quot;buenos días&quot; &quot;adiós&quot; Cambia la primera y la última letra en palabras. ¿Cuáles de esas cadenas siguen siendo palabras? Solución Primero, cambiemos la primera y la última letra. Para esto podemos utilizar grupos de captura y referencias previas. El patrón que queremos buscar son nuestros tres grupos de captura tendría que ser: 1. la primera letra (^([:alpha:])) 2. de la segunda a la penúltima letra ((.*)) 3. la última letra (([:alpha:])$) Luego, remplazamos con nuestro patrón con el primer y el último grupo invertido: \"\\\\3\\\\2\\\\1\" invertidas &lt;- str_replace_all(palabras, &quot;^([:alpha:])(.*)([:alpha:])$&quot;, &quot;\\\\3\\\\2\\\\1&quot;) head(invertidas) #&gt; [1] &quot;a&quot; &quot;lbria&quot; &quot;nccióa&quot; &quot;sccionea&quot; &quot;acerca&quot; &quot;dctitua&quot; La segunda pregunta es un poco amplia e implicaría revisar las 1000 palabras y evaluar en cada caso si es o no una palabra de nuestra lengua. Lo que sí podemos hacer es chequear si sigue siendo una palabra contenida en nuestro dataset palabras. Para ello, podemos utilizar dplyr::interset. Para eliminar las palabras y abreviaciones que tienen una sola letra (“y”, “a”, “o”, etc.), podemos comparar invertidas solo con las palabras de dos o más letras: intersect(invertidas, palabras[str_length(palabras) &gt; 1]) #&gt; [1] &quot;acerca&quot; &quot;agua&quot; &quot;ahora&quot; &quot;la&quot; #&gt; [5] &quot;alguna&quot; &quot;alta&quot; &quot;américa&quot; &quot;aquella&quot; #&gt; [9] &quot;argentina&quot; &quot;arriba&quot; &quot;ayuda&quot; &quot;le&quot; #&gt; [13] &quot;entre&quot; &quot;se&quot; &quot;ese&quot; &quot;especialmente&quot; #&gt; [17] &quot;especie&quot; &quot;este&quot; &quot;existe&quot; &quot;ii&quot; #&gt; [21] &quot;al&quot; &quot;el&quot; &quot;local&quot; &quot;sol&quot; #&gt; [25] &quot;ningún&quot; &quot;son&quot; &quot;objetivo&quot; &quot;objeto&quot; #&gt; [29] &quot;ocho&quot; &quot;oro&quot; &quot;otro&quot; &quot;pp&quot; #&gt; [33] &quot;realizar&quot; &quot;es&quot; &quot;sectores&quot; &quot;seis&quot; #&gt; [37] &quot;semanas&quot; &quot;servicios&quot; &quot;siguientes&quot; &quot;sistemas&quot; #&gt; [41] &quot;sociales&quot; &quot;los&quot; &quot;somos&quot; &quot;nos&quot; #&gt; [45] &quot;sus&quot; 14.3.6 Divisiones 14.3.6.1 Ejercicios Divide una cadena como \"manzanas, peras y bananas\" en elementos individuales. Solución x &lt;- c(&quot;manzanas, peras y bananas&quot;) str_split(x, &quot;(, )|( y )&quot;) #&gt; [[1]] #&gt; [1] &quot;manzanas&quot; &quot;peras&quot; &quot;bananas&quot; ¿Por qué es mejor dividir utilizando boundary(\"palabra\") en vez de \" \"? Solución El ejemplo que aparece en el libro muestra uno de los problemas de \" \": no elimina la puntuación. Es decir, no es capaz de indentificar claramente los límites de una palabra. boundary(\"word\") no tiene ese problema. x &lt;- &quot;Esta es una oración. Esta es otra oración&quot; str_split(x, &quot; &quot;)[[1]] #&gt; [1] &quot;Esta&quot; &quot;es&quot; &quot;una&quot; &quot;oración.&quot; &quot;Esta&quot; &quot;es&quot; &quot;otra&quot; #&gt; [8] &quot;oración&quot; str_split(x, boundary(&quot;word&quot;))[[1]] #&gt; [1] &quot;Esta&quot; &quot;es&quot; &quot;una&quot; &quot;oración&quot; &quot;Esta&quot; &quot;es&quot; &quot;otra&quot; #&gt; [8] &quot;oración&quot; ¿Qué pasa si dividimos con una cadena vacía (\"\")? Experimenta y luego lee la documentación Solución Experimentemos: str_split(&quot;palabra&quot;, &quot;&quot;)[[1]] #&gt; [1] &quot;p&quot; &quot;a&quot; &quot;l&quot; &quot;a&quot; &quot;b&quot; &quot;r&quot; &quot;a&quot; str_split(&quot;una frase&quot;, &quot;&quot;)[[1]] #&gt; [1] &quot;u&quot; &quot;n&quot; &quot;a&quot; &quot; &quot; &quot;f&quot; &quot;r&quot; &quot;a&quot; &quot;s&quot; &quot;e&quot; Una cadena vacía \"\" divide cada caracter de la cadena. 14.4 Otro tipo de patrones 14.4.1 Ejercicios ¿Cómo buscarías todas las cadenas que contienen \\ con regex() vs. con fixed()? Solución La diferencia se encuentra en la cadena que representa la expresión regular: barras &lt;- &quot;una barra \\\\, dos barras \\\\\\\\, tres barras \\\\\\\\\\\\&quot; writeLines(barras) #&gt; una barra \\, dos barras \\\\, tres barras \\\\\\ str_view_all(barras, regex(&quot;\\\\\\\\&quot;)) str_view_all(barras, fixed(\"\\\\\")) ¿Cuáles son las cinco palabras más comunes en oraciones? Solución Para resolver esta pregunta tenemos que extraer cada palabra de forma individual y luego contar su frecuencia. Podemos extraer todas las palabras de forma individual utilizando el código al final de esta sección. Luego, podemos convertir eso en un tibble y contar. No hay que olvidar convertir todas las mayúsculas a minúsculas con str_to_lower str_extract_all(oraciones, boundary(&quot;word&quot;)) %&gt;% unlist() %&gt;% # convertimos la lista en vector tibble(palabra = .) %&gt;% #creamos un tibble count(str_to_lower(palabra)) %&gt;% # contamos top_n(5) # buscamos las cinco más frecuentes #&gt; Selecting by n #&gt; # A tibble: 5 × 2 #&gt; `str_to_lower(palabra)` n #&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 de 26 #&gt; 2 el 29 #&gt; 3 en 16 #&gt; 4 la 30 #&gt; 5 y 14 Como era de esperar, las palabras más frecuentes son palabras de función como preposiciones, artículos y conjunciones. 14.6 stringi 14.6.1 Ejercicios Busca la función de stringi que: Cuenta el número de palabras. Busca cadenas duplicadas. Genera texto aleatorio. Solución Las funciones que nos sirven en cada uno de estos casos son: stringi::stri_count_words() stringi::stri_duplicated(palabras) stringi::stri_rand_lipsum() ¿Cómo puedes controlar qué lengua usa stri_sort() para ordenar? Solución Podemos controlar la lengua que se utiliza en stri_sort() con el argumento locale. El archivo de ayuda de esta función propone el siguiente ejemplo para ilustrar este comportamiento: stringi::stri_sort(c(&quot;hladny&quot;, &quot;chladny&quot;), locale=&quot;pl_PL&quot;) #&gt; [1] &quot;chladny&quot; &quot;hladny&quot; stringi::stri_sort(c(&quot;hladny&quot;, &quot;chladny&quot;), locale=&quot;sk_SK&quot;) #&gt; [1] &quot;hladny&quot; &quot;chladny&quot; "],["factores.html", "15 Factores 15.3 Encuesta social general 15.4 Modificar el orden de los factores 15.5 Modificar los niveles de los factores", " 15 Factores 15.3 Encuesta social general 15.3.1 Ejercicios Explora la distribución de ingreso. ¿Qué hace que el gráfico de barras por defecto sea tan difícil de comprender? ¿Cómo podrías mejorarlo? Solución Este es el gráfico por defecto: ggplot(encuesta) + aes(ingreso) + geom_bar() Resulta difícil de leer porque las etiquetas de los valores son muy largas. Una opción para resolver esto sería girando el gráfico. Esto se puede hacer con coord_flip() o, en la última versión de ggplot, moviendo la variable de eje: ggplot(encuesta) + aes(ingreso) + geom_bar() + coord_flip() # es lo mismo que ggplot(encuesta) + aes(y = ingreso) + geom_bar() En este caso particular no tendría tanto sentido ordenar las barras de forma ascendente o descente, ya que los datos ya tienen un orden. Algo que sí podríamos hacer es eliminar “No aplica” y cambiar el nombre de la etiqueta del eje x: encuesta %&gt;% filter(ingreso != &quot;No aplica&quot;) %&gt;% ggplot() + aes(y = ingreso) + geom_bar() + labs(x = &quot;Respuestas&quot;) ¿Cuál es la religion más común de la encuesta? ¿Cuál es el partido más común? Solución Una forma de encontrar el valor con mayor frecuencia sería contando con count() y luego ordenando de mayor a menor con arrange(desc()) para ver cuál queda primero. Otra opción es utilizar la función top_n(), también del paquete dplyr. La religión más común es “Protestante”: encuesta %&gt;% count(religion) %&gt;% top_n(1) #&gt; Selecting by n #&gt; # A tibble: 1 × 2 #&gt; religion n #&gt; &lt;fct&gt; &lt;int&gt; #&gt; 1 Protestante 10846 El valor más común en partido es “Independiente”: encuesta %&gt;% count(partido) %&gt;% top_n(1) #&gt; Selecting by n #&gt; # A tibble: 1 × 2 #&gt; partido n #&gt; &lt;fct&gt; &lt;int&gt; #&gt; 1 Independiente 4119 ¿A qué religion se aplica cada denominacion? ¿Cómo puedes encontrarlo con una tabla? ¿Cómo lo puedes descubrir con una visualización? Solución Una forma de hacerlo sería contar las combinaciones de religión y denominación, lo que nos entregaría una tabla en la que podríamos ver cada cruce (por ejemplo, con encuesta %&gt;% count(religion, denominacion)). Sin embargo, antes de hacer eso sería bueno eliminar los niveles que corresponden a una denominación: “Sin respuesta”, “No sabe”, “No aplica”, “No denominacional”: encuesta %&gt;% filter(!denominacion %in% c(&quot;Sin respuesta&quot;, &quot;No sabe&quot;, &quot;No aplica&quot;, &quot;No denominacional&quot;)) %&gt;% count(religion, denominacion) #&gt; # A tibble: 26 × 3 #&gt; religion denominacion n #&gt; &lt;fct&gt; &lt;fct&gt; &lt;int&gt; #&gt; 1 Protestante Otra 2534 #&gt; 2 Protestante Episcopal 397 #&gt; 3 Protestante Presbiteriana, no sabe cuál 244 #&gt; 4 Protestante Presbiteriana, fusionadas 67 #&gt; 5 Protestante Otra presbiteriana 47 #&gt; 6 Protestante Unión presbiteriana de iglesias 110 #&gt; # … with 20 more rows Las denominaciones corresponden a la religión Protestante. Podemos comprobar que es la única que aparece solo contando religion: encuesta %&gt;% filter(!denominacion %in% c(&quot;Sin respuesta&quot;, &quot;No sabe&quot;, &quot;No aplica&quot;, &quot;No denominacional&quot;)) %&gt;% count(religion) #&gt; # A tibble: 1 × 2 #&gt; religion n #&gt; &lt;fct&gt; &lt;int&gt; #&gt; 1 Protestante 9559 En una visualización lo podríamos descubrir con facet_wrap(). Podemos hacer un gráfico de columnas para la frecuencia de respuestas por cada denominación. Si faceteamos el gráfico según religión, solo nos aparecerá protestante porque en las otras religiones no hay valores. encuesta %&gt;% filter(!denominacion %in% c(&quot;Sin respuesta&quot;, &quot;No sabe&quot;, &quot;No aplica&quot;, &quot;No denominacional&quot;)) %&gt;% count(religion, denominacion) %&gt;% ggplot(aes(y = denominacion, x = n)) + geom_col() + facet_wrap(~religion) Como se comentó antes en el capítulo, ggplot descarta los niveles no utilizados. Si quisieras que los mostrara igual, podrías agregar la opción drop = FALSE, aunque como son tantos los niveles de denominacion quedarían amontonadas las etiquetas y habría que editar el tamaño del gráfico para evitar este problema: encuesta %&gt;% filter(!denominacion %in% c(&quot;Sin respuesta&quot;, &quot;No sabe&quot;, &quot;No aplica&quot;, &quot;No denominacional&quot;)) %&gt;% count(religion, denominacion) %&gt;% ggplot(aes(y = denominacion, x = n)) + geom_col() + facet_wrap(~religion, drop = FALSE) 15.4 Modificar el orden de los factores 15.4.1 Ejercicios Hay algunos números sospechosamente grandes en horas_tv. ¿Es la media un buen resumen? Solución Miremos los estadísticos de resumen y hagamos un histograma para explorar los datos: summary(encuesta$horas_tv) #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s #&gt; 0 1 2 3 4 24 10146 encuesta %&gt;% filter(!is.na(horas_tv)) %&gt;% ggplot(aes((horas_tv))) + geom_histogram(binwidth = 1) Efectivamente, hay valores demasiado altos. Pareciera que hay personas que ven televisión todo el día y no duermen nunca, lo que es poco verosímil. Podría ser mejor utilizar la mediana como resumen. En todo caso, estos números anormalmente altos son bastante pocos. Identifica, para cada factor en encuesta, si el orden de los niveles es arbitrario o responde a algún principio. Solución Primero, identifiquemos qué variables son factores. Una forma de hacerlo es utilizar select_if, que selecciona columnas de acuerdo a una condición, y luego extraer los nombres de las variables. encuesta %&gt;% select_if(is.factor) %&gt;% names() #&gt; [1] &quot;estado_civil&quot; &quot;raza&quot; &quot;ingreso&quot; &quot;partido&quot; &quot;religion&quot; #&gt; [6] &quot;denominacion&quot; Ahora, revisemos los niveles de cada una de ellas. En el caso de estado_civil pareciera que tenemos dos extremos: nunca se ha casado y casado, y entre ellas están agrupadas las categorías que hacen alusión a gente que estuvo casada, pero ya no. levels(encuesta$estado_civil) #&gt; [1] &quot;Sin respuesta&quot; &quot;Nunca se ha casado&quot; &quot;Separado&quot; #&gt; [4] &quot;Divorciado&quot; &quot;Viudo&quot; &quot;Casado&quot; En la variable raza pareciera no haber ningún orden en particular: levels(encuesta$raza) #&gt; [1] &quot;Otra&quot; &quot;Negra&quot; &quot;Blanca&quot; &quot;No aplica&quot; Si visualizamos los datos, es posible ver que los tres primeros niveles se ordenaron por frecuencia. ggplot(encuesta, aes(raza)) + geom_bar() + scale_x_discrete(drop = FALSE) ingreso está ordenado por rangos que van de mayor a menor. levels(encuesta$ingreso) #&gt; [1] &quot;Sin respuesta&quot; &quot;No sabe&quot; &quot;Se niega a responder&quot; #&gt; [4] &quot;25000 o más&quot; &quot;20000 - 24999&quot; &quot;15000 - 19999&quot; #&gt; [7] &quot;10000 - 14999&quot; &quot;8000 - 9999&quot; &quot;7000 - 7999&quot; #&gt; [10] &quot;6000 - 6999&quot; &quot;5000 - 5999&quot; &quot;4000 - 4999&quot; #&gt; [13] &quot;3000 - 3999&quot; &quot;1000 - 2999&quot; &quot;Menos de 1000&quot; #&gt; [16] &quot;No aplica&quot; Los niveles de partido están ordenados a partir de más republicano a más demócrata. levels(encuesta$partido) #&gt; [1] &quot;Sin respuesta&quot; &quot;No sabe&quot; #&gt; [3] &quot;Otro partido&quot; &quot;Fuertemente republicano&quot; #&gt; [5] &quot;No fuertemente republicano&quot; &quot;Ind, pro rep&quot; #&gt; [7] &quot;Independiente&quot; &quot;Ind, pro dem&quot; #&gt; [9] &quot;No fuertemente demócrata&quot; &quot;Fuertemente demócrata&quot; religión pareciera no tener ningún orden en particular: levels(encuesta$religion) #&gt; [1] &quot;Sin respuesta&quot; &quot;No sabe&quot; &quot;Inter o no confesional&quot; #&gt; [4] &quot;Nativa americana&quot; &quot;Cristiana&quot; &quot;Cristiana ortodoxa&quot; #&gt; [7] &quot;Musulmana/Islam&quot; &quot;Otra religión oriental&quot; &quot;Hinduismo&quot; #&gt; [10] &quot;Budismo&quot; &quot;Otra&quot; &quot;Ninguna&quot; #&gt; [13] &quot;Judía&quot; &quot;Católica&quot; &quot;Protestante&quot; #&gt; [16] &quot;No aplica&quot; Si visualizamos para chequear, podemos confirmar el orden aleatorio: ggplot(encuesta, aes(y = religion)) + geom_bar() + scale_x_discrete(drop = FALSE) En el caso de denominacion, los niveles que pertencen a variantes de una denominacion (luterana, episcopal, metodista, etc.) están agrupados. Pero estos grupos entre sí no responden a un orden en particular: levels(encuesta$denominacion) #&gt; [1] &quot;Sin respuesta&quot; #&gt; [2] &quot;No sabe&quot; #&gt; [3] &quot;No denominacional&quot; #&gt; [4] &quot;Otra&quot; #&gt; [5] &quot;Episcopal&quot; #&gt; [6] &quot;Presbiteriana, no sabe cuál&quot; #&gt; [7] &quot;Presbiteriana, fusionadas&quot; #&gt; [8] &quot;Otra presbiteriana&quot; #&gt; [9] &quot;Unión presbiteriana de iglesias&quot; #&gt; [10] &quot;Iglesia presbiteriana de los EEUU&quot; #&gt; [11] &quot;Luterana, no sabe cuál&quot; #&gt; [12] &quot;Evangélica luterana&quot; #&gt; [13] &quot;Otras luteranas&quot; #&gt; [14] &quot;Sínodo evangélico luterano de Wisconsin&quot; #&gt; [15] &quot;Sínodo luterano&quot; #&gt; [16] &quot;Iglesia luterana de EEUU&quot; #&gt; [17] &quot;Iglesia luterana americana&quot; #&gt; [18] &quot;Metodista, no sabe cuál&quot; #&gt; [19] &quot;Otras metodistas&quot; #&gt; [20] &quot;Iglesia metodista unida&quot; #&gt; [21] &quot;Iglesia africana metodista episcopal de Sion&quot; #&gt; [22] &quot;Iglesia africana metodista episcopal&quot; #&gt; [23] &quot;Bautista, no sabe cuál&quot; #&gt; [24] &quot;Otras bautistas&quot; #&gt; [25] &quot;Bautistas del sur&quot; #&gt; [26] &quot;Convención nacional bautista de EEUU&quot; #&gt; [27] &quot;Convención nacional baptista de america&quot; #&gt; [28] &quot;Iglesias bautistas de EEUU&quot; #&gt; [29] &quot;Asociación bautista estadounidense&quot; #&gt; [30] &quot;No aplica&quot; ¿Por qué mover “No aplica” al inicio de los niveles lo llevó al final del gráfico? Solución 15.5 Modificar los niveles de los factores 15.5.1 Ejercicios ¿Cómo han cambiado en el tiempo las proporciones de personas que se identifican como Demócratas, Republicanas e Independientes? Solución Para responder esta pregunta vamos a usar la versión de los datos que se muestran al final de esta sección en que los niveles de partido se agruparon con factor_collapse) partido_anio &lt;- encuesta %&gt;% mutate(partido = fct_collapse(partido, otro = c(&quot;Sin respuesta&quot;, &quot;No sabe&quot;, &quot;Otro partido&quot;), republicano = c(&quot;Fuertemente republicano&quot;, &quot;No fuertemente republicano&quot;), independiente = c(&quot;Ind, pro rep&quot;, &quot;Independiente&quot;, &quot;Ind, pro dem&quot;), demócrata = c(&quot;No fuertemente demócrata&quot;, &quot;Fuertemente demócrata&quot;) )) %&gt;% count(anio, partido) ggplot(partido_anio) + aes(anio, n, colour = partido) + geom_line() Sería mejor si más que el número de respuestas, graficáramos la proporción: partido_anio %&gt;% group_by(anio) %&gt;% mutate(proporcion = n / sum(n)) %&gt;% ggplot() + aes(anio, proporcion, colour = partido) + geom_line() ¿Cómo podrías colapsar ingreso en un grupo más pequeño de categorías? Solución Actualmente los niveles agrupan los datos de tres formas: tramos de mil, dos mil y cinco mil dólares: levels(encuesta$ingreso) #&gt; [1] &quot;Sin respuesta&quot; &quot;No sabe&quot; &quot;Se niega a responder&quot; #&gt; [4] &quot;25000 o más&quot; &quot;20000 - 24999&quot; &quot;15000 - 19999&quot; #&gt; [7] &quot;10000 - 14999&quot; &quot;8000 - 9999&quot; &quot;7000 - 7999&quot; #&gt; [10] &quot;6000 - 6999&quot; &quot;5000 - 5999&quot; &quot;4000 - 4999&quot; #&gt; [13] &quot;3000 - 3999&quot; &quot;1000 - 2999&quot; &quot;Menos de 1000&quot; #&gt; [16] &quot;No aplica&quot; Una forma de colapsaros en menos categorías sería solo utilizar los tramos de 5000 dólares. Esto hace sentido si revisamos cómo se distribuyen los datos: ggplot(encuesta) + aes(y = ingreso) + geom_bar() Para la agrupación, podemos utilizar fct_collapse() encuesta %&gt;% mutate(ingreso_reagrupado = fct_collapse(ingreso, &quot;Menos de 5000&quot; = c(&quot;Menos de 1000&quot;, &quot;1000 - 2999&quot;, &quot;3000 - 3999&quot;, &quot;4000 - 4999&quot;), &quot;5000 - 9999&quot; = c(&quot;5000 - 5999&quot;, &quot;6000 - 6999&quot;, &quot;7000 - 7999&quot;, &quot;8000 - 9999&quot;))) %&gt;% ggplot() + aes(y = ingreso_reagrupado) + geom_bar() También podemos reagrupar “Sin respuesta”, “No sabe”, “Se niega a responder” y “No aplica” en una categoría a la que podríamos llamar “Desconocido” o “Sin información”. Editemos el código anterior para que refleje este cambio: encuesta %&gt;% mutate(ingreso_reagrupado = fct_collapse(ingreso, &quot;Menos de 5000&quot; = c(&quot;Menos de 1000&quot;, &quot;1000 - 2999&quot;, &quot;3000 - 3999&quot;, &quot;4000 - 4999&quot;), &quot;5000 - 9999&quot; = c(&quot;5000 - 5999&quot;, &quot;6000 - 6999&quot;, &quot;7000 - 7999&quot;, &quot;8000 - 9999&quot;), &quot;Sin información&quot; = c(&quot;Sin respuesta&quot;, &quot;No sabe&quot;, &quot;Se niega a responder&quot;, &quot;No aplica&quot;) )) %&gt;% ggplot() + aes(y = ingreso_reagrupado) + geom_bar() "],["horas-y-fechas.html", "16 Horas y fechas 16.2 Creando horas/fechas 16.3 Componentes fecha-hora 16.4 Lapsos de tiempo", " 16 Horas y fechas 16.2 Creando horas/fechas 16.2.4 Ejercicios ¿Qué sucede si analizas una cadena de caracteres que contiene fechas inválidas? ymd(c(&quot;2010-10-10&quot;, &quot;bananas&quot;)) Solución Las cadenas de caracteres que contienen cadenas inválidas se convierten en NA y R arroja un mensaje de advertencia en el que se indica la candidad de veces que se encontró con este error: [1] &quot;2010-10-10&quot; NA Warning message: 1 failed to parse. ¿Qué hace el argumento tzone (del inglés, huso horario abreviado) para today()? ¿Por qué es importante? Solución El argumento tzone permite indicar en qué huso horarios queremos la fecha actual. Por defecto entrega la de tu sistema, pero si queremos la de una zona horaria específica, podemos ajustarla con ese argumento: today() #&gt; [1] &quot;2021-12-31&quot; today (&quot;UTC&quot;) #&gt; [1] &quot;2021-12-31&quot; today(tzone = &quot;Australia/Sydney&quot;) #&gt; [1] &quot;2022-01-01&quot; today(tzone = &quot;Pacific/Honolulu&quot;) #&gt; [1] &quot;2021-12-31&quot; Usa la función de lubridate apropiada para analizar las siguientes fechas: d1 &lt;- &quot;Enero 1, 2010&quot; d2 &lt;- &quot;2015-Mar-07&quot; d3 &lt;- &quot;06-Jun-2017&quot; d4 &lt;- c(&quot;Agosto 19 (2015)&quot;, &quot;Julio 1 (2015)&quot;) d5 &lt;- &quot;12/30/14&quot; # Diciembre 30, 2014 Solución mdy(d1) #&gt; Warning: All formats failed to parse. No formats found. #&gt; [1] NA ymd(d2) #&gt; [1] &quot;2015-03-07&quot; dmy(d3) #&gt; [1] &quot;2017-06-06&quot; mdy(d4) #&gt; Warning: All formats failed to parse. No formats found. #&gt; [1] NA NA mdy(d5) #&gt; [1] &quot;2014-12-30&quot; 16.3 Componentes fecha-hora 16.3.4 Ejercicios ¿Cómo cambia la distribución de las horas de los vuelos dentro de un día, a lo largo del año? Solución Compara horario_salida, salida_programada and atraso_salida. ¿Son consistentes? Explica tus hallazgos. Solución Compara tiempo_vuelo con la duración entre la salida y la llegada. Explica tus hallazgos. (Pista: considera la ubicación del aeropuerto). Solución ¿Cómo cambia la demora promedio durante el curso de un día? ¿Deberías usar horario_salida o salida_programada? ¿Por qué? Solución ¿En qué día de la semana deberías salir, si quieres minimizar las posibilidades de una demora? Solución ¿Qué hace que la distribución de diamantes$quilate y vuelos$salida_programada sean similares? Solución Confirma mi hipótesis de que salidas programas en los minutos 20-30 y 50-60 están casuadas por los vuelos programados que salen más temprano. Pista: crea una variable binaria que te diga si un vuelo tuvo o no demora. Solución 16.4 Lapsos de tiempo 16.4.5 Ejercicios ¿Por qué hay months() pero no dmonths() (días del mes)? Solución Explica days(nocturno * 1) a alguien que apenas comienza a aprender R. ¿Cómo funciona? Solución Crea un vector de fechas dando el primer día de cada mes en 2015. Crea un vector de fechas dando el primer día de cada mes del año actual. Solución Una manera de resolver la primera pregunta sería obtener el primer día del primer mes y luego sumarle 11 meses: ymd(&quot;2015-01-01&quot;) + months(0:11) #&gt; [1] &quot;2015-01-01&quot; &quot;2015-02-01&quot; &quot;2015-03-01&quot; &quot;2015-04-01&quot; &quot;2015-05-01&quot; #&gt; [6] &quot;2015-06-01&quot; &quot;2015-07-01&quot; &quot;2015-08-01&quot; &quot;2015-09-01&quot; &quot;2015-10-01&quot; #&gt; [11] &quot;2015-11-01&quot; &quot;2015-12-01&quot; La segunda pregunta podemos resolverla de las misma manera, pero obteniendo el primer día del año actual. Como queremos que esta respuesta sirva el próximo año, tenemos que generar ese primer día de manera automática (y no solo escribiendo \"2020-01-01\"). Para ello, podemos redondear hacia abajo la fecha actual. floor_date() permite indicar el criterio de redondeo: floor_date(today(), &quot;year&quot;) #&gt; [1] &quot;2021-01-01&quot; Ahora que obtuvimos el primer día del año actual, podemos sumarle los meses: floor_date(today(), &quot;year&quot;) + months(0:11) #&gt; [1] &quot;2021-01-01&quot; &quot;2021-02-01&quot; &quot;2021-03-01&quot; &quot;2021-04-01&quot; &quot;2021-05-01&quot; #&gt; [6] &quot;2021-06-01&quot; &quot;2021-07-01&quot; &quot;2021-08-01&quot; &quot;2021-09-01&quot; &quot;2021-10-01&quot; #&gt; [11] &quot;2021-11-01&quot; &quot;2021-12-01&quot; Crea una función en la cual, dado tu cumpleaños (como una fecha), retorne cuán viejo eres en años. Solución ¿Por qué no puedes hacer funcionar a (today() %--% (today() + years(1)) / months(1) ? Solución "],["introducción-6.html", "17 Introducción", " 17 Introducción Esta sección no tiene ejercicios. "],["pipes.html", "18 Pipes", " 18 Pipes [capítulo sin ejercicios] "],["funciones.html", "19 Funciones 19.2 ¿Cuándo deberías escribir una función? 19.3 Las funciones son para los humanos y las computadoras 19.4 Ejecución condicional 19.5 Argumentos de funciones", " 19 Funciones 19.2 ¿Cuándo deberías escribir una función? 19.2.1 Ejercicios ¿Por qué TRUE no es un parámetro para rescale01()? ¿Qué pasaría si x está contenido en un valor único perdido y na.rm fuese FALSE? Solución En la segunda variante de rescale01(), los valores infinitos se dejan sin cambio. Reescribe rescale01() así -Inf is convertido a 0, y Inf es convertido a 1. Solución Practica convertir los siguientes fragmentos de código en funciones. Piensa en lo que hace cada función. ¿Cómo lo llamarías? ¿Cuántos argumentos necesita? ¿Puedes reescribirlo para ser más expresivo o menos duplicado? mean(is.na(x)) x / sum(x, na.rm = TRUE) sd(x, na.rm = TRUE) / mean(x, na.rm = TRUE) Solución Escribe tus propias funciones para computar la variancia y la inclinación de un vector numérico. La varianza se define como \\[ \\mathrm{Var}(x) = \\frac{1}{n - 1} \\sum_{i=1}^n (x_i - \\bar{x}) ^2 \\text{,} \\] donde \\(\\bar{x} = (\\sum_i^n x_i) / n\\) es la media de la muestra. La inclinación se define como \\[ \\mathrm{Skew}(x) = \\frac{\\frac{1}{n-2}\\left(\\sum_{i=1}^n(x_i - \\bar x)^3\\right)}{\\mathrm{Var}(x)^{3/2}} \\text{.} \\] Solución Escribe both_na(), una función que toma dos vectores de la misma longitud y retorna el número de posiciones que tiene NA en ambos vectores. Solución ¿Qué hacen las siguientes funciones? ¿Por qué son tan útiles aún cuando son tan cortas? is_directory &lt;- function(x) file.info(x)$isdir is_readable &lt;- function(x) file.access(x, 4) == 0 Solución Lee el complete lyrics de “Pequeño conejito Foo Foo”. Como ves, hay mucha duplicación en la letra de la canción. Extiende el ejemplo inicial de pipes para recrear la canción completa, usar las funciones para reducir la duplicación. Solución 19.3 Las funciones son para los humanos y las computadoras 19.3.1 Ejercicios Lee el código fuente para cada una de las siguientes tres funciones, interpreta que hacen, y luego propone nombres mejores. f1 &lt;- function(string, prefix) { substr(string, 1, nchar(prefix)) == prefix } f2 &lt;- function(x) { if (length(x) &lt;= 1) return(NULL) x[-length(x)] } f3 &lt;- function(x, y) { rep(y, length.out = length(x)) } Solución Toma una función que hayas escrito recientemente y tómate 5 minutos para pensar un mejor nombre para la función y para sus argumentos. Solución Compara y contrasta rnorm() y MASS::mvrnorm(). ¿Cómo podrías hacerlas más consistentes? Solución Argumenta porqué norm_r(),norm_d() etc sería una mejor opción que rnorm(), dnorm(). Argumenta lo contrario. Solución 19.4 Ejecución condicional 19.4.4 Ejercicios ¿Cuál es la diferencia entre if and ifelse()? Lee cuidadosamente la ayuda y construye tres ejemplos que ilustren las diferencias claves. Solución Escribe una función de saludo que diga “buenos días”, “buenas tardes” o “buenas noches”, según la hora del día. (Sugerencia: usa un argumento de tiempo que por defecto es lubridate::now(), eso hará que sea más fácil testear tu función). Solución Implementa una función fizzbuzz que tenga un solo número como input. Si el número es divisible por tres, devuelve “fizz”. Si es divisible por cinco, devuelve “buzz”. Si es divisible por tres y cinco, devuelve “fizzbuzz”. De lo contrario, devuelve el número. Asegúrate de escribir primero código que funciones antes de crear la función. Solución ¿Cómo podrías usar cut() para simplificar este conjunto de sentencias if-else anidada? if (temp &lt;= 0) { &quot;congelado&quot; } else if (temp &lt;= 10) { &quot;helado&quot; } else if (temp &lt;= 20) { &quot;fresco&quot; } else if (temp &lt;= 30) { &quot;tibio&quot; } else { &quot;caluroso&quot; } ¿Cómo cambiarías la sentencia a cut() si hubieras usado &lt;en lugar de &lt;=? ¿Cuál es la otra ventaja principal de cut() para este problema? (Sugerencia: ¿qué sucede si tienes muchos valores en temp?) Solución ¿Qué sucede si usaras switch() con un valor numérico? Solución ¿Qué hace la llamada a switch()? ¿Qúe sucede si x fuera “e”? switch(x, a = , b = &quot;ab&quot;, c = , d = &quot;cd&quot; ) Experimenta, luego lea cuidadosamente la documentación. Solución 19.5 Argumentos de funciones 19.5.5 Ejercicios ¿Qué realiza commas(letters, collapse = \"-\")? ¿Por qué? Solución Sería bueno si se pudiera suplantar múltiples caracteres al argumento pad, ej., rule(\"Title\", pad = \"-+\"). ¿Por qué esto actualmente no funciona? ¿Cómo podrías solucionarlo? Solución ¿Qué realiza el argumento trim a la función mean()? ¿Cuándo podrías utilizarla? Solución El valor de defecto para el argumento method a cor() es c(\"pearson\", \"kendall\", \"spearman\"). ¿Qué significa esto? ¿Qué valor se utiliza por defecto? Solución "],["vectores.html", "20 Vectores 20.3 Tipos importantes de vectores atómicos 20.4 Usando vectores atómicos 20.5 Vectores Recursivos (listas) 20.7 Vectores Aumentados", " 20 Vectores 20.3 Tipos importantes de vectores atómicos 20.3.5 Ejercicios Describe la diferencia entre is.finite(x) y !is.infinite(x). Solución Lee el código fuente de dplyr:: near() (Consejo: para ver el código fuente, escribe lo siguiente ()) ¿Funcionó? Solución Un vector de tipo lógico puede tomar 3 valores posibles. ¿Cuántos valores posibles puede tomar un vector de tipo entero? ¿Cuántos valores posibles puede tomar un vector de tipo real? Usa Google para realizar buscar información respecto a lo planteado anteriormente. Solución Idea al menos 4 funciones que te permitan convertir un vector del tipo real a entero. ¿En qué difieren las funciones? Precisa tu respuesta. Solución ¿Cuáles funciones del paquete readr te permiten convertir un vector del tipo string en un vector del tipo lógico, entero y doble? Solución 20.4 Usando vectores atómicos 20.4.6 Ejercicios La expresión mean(is.na(x)), ¿qué dice acerca del vector ‘x’? ¿y qué sucede con la expresión sum(!is.finite(x))? Solución Detenidamente lee la documentación de is.vector(). ¿Para qué se prueba la función realmente? ¿Por qué la función is.atomic() no concuerda con la definición de vectores atómicos vista anteriormente? Solución Compara y contraste setNames() con purrr::set_names(). Solución Crea funciones que tomen un vector como entrada y devuelva: El último valor. ¿Deberás usar [ o [[?. Los elementos en posiciones pares. Cada elemento excepto el último valor. Sólo las posiciones pares (y sin valores perdidos (missing values)). Solución ¿Por qué x[-which(x &gt; 0)] no es lo mismo que x[x &lt;= 0]? Solución ¿Qué sucede cuando realizas un subset (subdivisión) con un entero positivo que es mayor que la longitud del vector? ¿Qué sucede cuando realizas un subset (subdivisión) con un nombre que no existe? Solución 20.5 Vectores Recursivos (listas) 20.5.4 Ejercicios 1.Dibuja las listas siguientes como sets anidados: list(a, b, list(c, d), list(e, f)) list(list(list(list(list(list(a)))))) Solución 2.¿Qué pasaría si subdividieras un tibble como si fuera una lista? ¿Cuáles son las principales diferencias entre una lista y un tibble? Solución 20.7 Vectores Aumentados 20.7.4 Ejecicios ¿Qué valor retorna la siguiente expresión hms::hms(3600)? ¿Cómo se muestra? ¿Cuál es la tipo primario sobre el cual se basa el vector aumentado? ¿Qué atributos utiliza el mismo? Solución Intenta y crea un tibble que tenga columnas con diferentes longitudes. ¿Qué es lo que ocurre? Solución Teniendo en cuenta la definición anterior, ¿está bien tener una lista como columna en un tibble? Solución "],["iteración.html", "21 Iteración 21.2 Bucles for 21.3 Variaciones de bucles for 21.1 21.4 Bucles for vs. funcionales{-for-funcionales 21.5 Las funciones map 21.9.1 Otros patrones para los bucles for", " 21 Iteración 21.2 Bucles for 21.2.1 Ejercicios Escribir bucles for para: Calcular la media de cada columna en mtautos. Determinar el tipo de cada columna en vuelos. Calcular el número de valores únicos en cada columna de iris. Genera 10 normales aleatorias para cada valor de \\(\\mu = -10\\), \\(0\\), \\(10\\) y \\(100\\). Piensa en el resultado, la secuencia y el cuerpo antes de empezar a escribir el bucle. Solución Elimina el bucle for en cada uno de los siguientes ejemplos tomando ventaja de una función existente que trabaja con vectores: out &lt;- &quot;&quot; for (x in letters) { out &lt;- stringr::str_c(out, x) } x &lt;- sample(100) sd &lt;- 0 for (i in seq_along(x)) { sd &lt;- sd + (x[i] - mean(x)) ^ 2 } sd &lt;- sqrt(sd / (length(x) - 1)) x &lt;- runif(100) out &lt;- vector(&quot;numeric&quot;, length(x)) out[1] &lt;- x[1] for (i in 2:length(x)) { out[i] &lt;- out[i - 1] + x[i] } Solución Combina tus habilidades para escribir funciones y bucles for: Escribe un bucle for que imprima (prints()) la letra de la canción de niños “Cinco ranitas verdes”. Solución 2. Convierte la canción infantil &quot;10 monitos saltaban en la cama&quot; en una función. Generalizar a cualquier cantidad de monitos en cualquier estructura para dormir. Solución 3. Convierte la canción &quot;99 botellas de cerveza en la pared&quot; en una función. Generalizar a cualquier cantidad, de cualquier tipo de recipiente que contenga cualquier líquido sobre cualquier superficie. Solución Es común ver bucles for que no preasignan la salida y en su lugar aumentan la longitud de un vector en cada paso: output &lt;- vector(&quot;integer&quot;, 0) for (i in seq_along(x)) { output &lt;- c(output, lengths(x[[i]])) } output ¿Cómo afecta esto el rendimiento? Diseña y ejecuta un experimento. Solución 21.3 Variaciones de bucles for 21.3.5 Ejercicios Imaginemos que tenemos un directorio lleno de archivos CSV que queremos leer. Tenemos sus ubicaciones en un vector, files &lt;- dir(\"data/\", pattern = \"\\\\.csv$\", full.names = TRUE), y ahora queremos leer cada uno con read_csv(). Escribe un bucle for que los cargue en un solo data frame. Solución ¿Qué pasa si utilizamos for (nm in names(x)) y x no tiene names? ¿Qué pasa si solo algunos elementos están nombrados (named en inglés) ¿Qué pasa si los nombres (names en inglés) no son únicos? Solución Escribe una función que imprima el promedio de cada columna numérica en un data frame, junto con su nombre. Por ejemplo, mostrar_promedio(iris) debe imprimir: mostrar_promedio(iris) #&gt; Sepal.Length: 5.84 #&gt; Sepal.Width: 3.06 #&gt; Petal.Length: 3.76 #&gt; Petal.Width: 1.20 (Desafío adicional: ¿qué función utilizamos para asegurarnos que los números queden alineados a pesar que los nombres de las variables tienen diferentes longitudes?) Solución ¿Qué hace este código? ¿Cómo funciona? trans &lt;- list( disp = function(x) x * 0.0163871, am = function(x) { factor(x, labels = c(&quot;auto&quot;, &quot;manual&quot;)) } ) for (var in names(trans)) { mtcars[[var]] &lt;- trans[[var]](mtcars[[var]]) } Solución 21.1 21.4 Bucles for vs. funcionales{-for-funcionales 21.4.1 Ejercicios Lee la documentación para apply (). En el caso 2d, ¿qué dos bucles for generaliza? Solución Adapta col_summary () para que solo se aplique a las columnas numéricas. Es posible que desees comenzar con la función is_numeric () que devuelve un vector lógico que tenga un TRUE por cada columna numérica. Solución 21.5 Las funciones map 21.5.3 Ejercicios Escribe un código que use una de las funciones de map para: Calcular la media de cada columna en mautos. Obtener de que tipo es cada columna en vuelos. Calcular la cantidad de valores únicos en cada columna de iris. Generar diez normales aleatorias para cada \\(\\mu = -10\\), \\(0\\), \\(10\\), and \\(100\\). Solución ¿Cómo puedes crear un vector tal que para cada columna en un cuadro de datos indique si corresponde o no a un factor? Solución ¿Qué ocurre si usas las funciones map en vectores que no son listas? ¿Qué hace map(1:5, runif)? ¿Por qué? Solución ¿Qué hace map(-2:2, rnorm, n = 5)? ¿Por qué? ¿Qué hace map_dbl(-2:2, rnorm, n = 5)? ¿Por qué? Solución Reescribe map(x, function(df) lm(mpg ~ wt, data = df)) para eliminar todas las funciones anónimas. Solución 21.9.1 Otros patrones para los bucles for 21.9.3 Ejercicios Implementa tu propia versión de every() usando un loop for. Comparala con purrr::every(). ¿Qué hace la versión de purrr que la tuya no hace? Solución Crea una mejora de col_sum() que aplique una función de resumen a cada columna numérica en un data frame. Solución Un posible equivalente de col_sum() es: col_sum3 &lt;- function(df, f) { is_num &lt;- sapply(df, is.numeric) df_num &lt;- df[, is_num] sapply(df_num, f) } Pero tiene una cantidad de bugs que queda ilustrada con las siguientes entradas: df &lt;- tibble( x = 1:3, y = 3:1, z = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) ) # OK col_sum3(df, mean) # Tiene problemas: no siempre devuelve un vector numérico col_sum3(df[1:2], mean) col_sum3(df[1], mean) col_sum3(df[0], mean) ¿Qué causa los bugs? Solución "],["introducción-7.html", "22 Introducción", " 22 Introducción Sección sin ejercicios. "],["modelos-conceptos-básicos.html", "23 Modelos: conceptos básicos 23.2 Un modelo simple 23.3 Visualizando modelos 23.4 Fórmulas y familias de modelos", " 23 Modelos: conceptos básicos 23.2 Un modelo simple 23.2.1 Ejercicios Una desventaja del modelo lineal es ser sensible a valores inusuales debido a que la distancia incorpora un término al cuadrado. Ajusta un modelo a los datos simulados que se presentan a continuación y visualiza los resultados. Corre el modelo varias veces para generar diferentes conjuntos de datos simulados. ¿Qué puedes observar respecto del modelo? sim1a &lt;- tibble( x = rep(1:10, each = 3), y = x * 1.5 + 6 + rt(length(x), df = 2) ) Solución Se puede correr una vez y graficar los resultados. ggplot(sim1a, aes(x = x, y = y)) + geom_point() + geom_smooth(method = &quot;lm&quot;, se = FALSE) #&gt; `geom_smooth()` using formula &#39;y ~ x&#39; Para sistematizarlo, se pueden generar varias simulaciones y luego graficar las líneas. simt &lt;- function(i) { tibble( x = rep(1:10, each = 3), y = x * 1.5 + 6 + rt(length(x), df = 2), .id = i ) } sims &lt;- map_df(1:12, simt) ggplot(sims, aes(x = x, y = y)) + geom_point() + geom_smooth(method = &quot;lm&quot;, colour = &quot;red&quot;) + facet_wrap(~.id, ncol = 4) #&gt; `geom_smooth()` using formula &#39;y ~ x&#39; El ejercicio usa la función rt() la cual entrega un muestreo a partir de una distribución t-Student, la cual tiene colas más largas que la distribución normal (rnorm()), por lo tanto asigna una mayor probabilidad a los valores fuera del centro de la distribución. ¿Qué ocurre si usamos una distribución normal? sim_norm &lt;- function(i) { tibble( x = rep(1:10, each = 3), y = x * 1.5 + 6 + rnorm(length(x)), .id = i ) } simdf_norm &lt;- map_df(1:12, sim_norm) ggplot(simdf_norm, aes(x = x, y = y)) + geom_point() + geom_smooth(method = &quot;lm&quot;, colour = &quot;red&quot;) + facet_wrap(~.id, ncol = 4) #&gt; `geom_smooth()` using formula &#39;y ~ x&#39; Al usar distribución normal no hay tantos valores extremos y las pendientes son más similares. Para el caso de la distribución normal con media cero y desviación estándar uno, la probabilidad de que un valor sea mayor a dos se obtiene con pnorm(). pnorm(2, lower.tail = FALSE) #&gt; [1] 0.0228 Para el caso de la distribución t-Student con dos grados de libertad, la probabilidad es más del triple del caso anterior y se obtiene con pt(). pt(2, df = 2, lower.tail = FALSE) #&gt; [1] 0.0918 Podemos concluir que el modelo es sensible a valores extremos y en general a la distribución que siguen los datos. Una forma de obtener un modelo lineal más robusto es usar una métrica distinta para la distancia. Por ejemplo, en lugar de la raíz de la distancia media cuadrática (del inglés root-mean-squared distance) se podría usar la media de la distancia absoluta: medir_distancia &lt;- function(modelo, datos) { diferencia &lt;- datos$y - modelo1(modelo, datos) mean(abs(diferencia)) } Usa optim() para ajustar este modelo a los datos simulados anteriormente y compara el resultado con el modelo lineal. Solución Usando los datos sim1a y optim() podemos encontrar los parámetros que minimizan la desviación absoluta. Definiremos la función modelo1() tal como se hizo en el libro. modelo1 &lt;- function(a, datos) { a[1] + datos$x * a[2] } beta &lt;- optim(c(0, 0), medir_distancia, datos = sim1a) beta$par #&gt; [1] 5.25 1.66 Los resultados del modelo lineal son los mismos que se obtienen si se minimiza la desviación al cuadrado. medir_distancia_ml &lt;- function(modelo, datos) { diferencia &lt;- datos$y - (modelo[1] + modelo[2] * datos$x) sqrt(mean(diferencia^2)) } beta &lt;- optim(c(0, 0), medir_distancia_ml, datos = sim1a) beta$par #&gt; [1] 5.87 1.56 En la práctica no es recomendable usar optim() para ajustar un modelo, es mejor utilizar implementaciones ya existentes como rlm() y lqs() que son parte del paquete MASS. La justificación es que estas implementaciones permiten ajustar modelos robustos sin los múltiples problemas de carácter numérico que pueden surgir de manera condicional a los datos al momento de usar optim(). Un desafío al realizar optimización numérica es que únicamente garantiza encontrar un óptimo local. ¿Qué problema se presenta al optimizar un modelo de tres parámetros como el que se presenta a continuación? modelo3 &lt;- function(a, datos) { a[1] + datos$x * a[2] + a[3] } Solución El problema es que dados los valores a[1] = a1 y a[3] = a3, cualquier otra combinación de a[1] y a[3] tal que a[1] + a[3] == (a1 + a3) tendrá el mismo ajuste. medir_distancia_3_ml &lt;- function(a, datos) { diferencia &lt;- datos$y - modelo3(a, datos) sqrt(mean(diferencia^2)) } Dependiendo de los valores inciales se van a obtener distintos valores óptimos. beta_000 &lt;- optim(c(0, 0, 0), medir_distancia_3_ml, datos = sim1a) beta_000$par #&gt; [1] 6.461 1.564 -0.594 beta_001 &lt;- optim(c(0, 0, 1), medir_distancia_3_ml, datos = sim1a) beta_001$par #&gt; [1] -8.38 1.56 14.25 beta_005 &lt;- optim(c(0, 0, 5), medir_distancia_3_ml, datos = sim1a) beta_005$par #&gt; [1] 0.596 1.564 5.272 Si seguimos alterando los valores inciales no es muy difícil concluir que existen infinitos valores óptimos para este modelo. 23.3 Visualizando modelos 23.3.3 Ejercicios En lugar de usar lm() para ajustar una línea recta, puedes usar loess() para ajustar una curva suave. Repite el proceso de ajustar el modelo, generar la cuadrícula, predicciones y visualización con sim1 usando loess() en vez de lm(). ¿Cómo se compara el resultado a geom_smooth(). Solución Usando add_predictions() y add_residuals() se pueden agregar las predicciones y los residuos de la regresión loess a los datos sim1a. sim1_loess &lt;- loess(y ~ x, data = sim1a) sim1_lm &lt;- lm(y ~ x, data = sim1a) grid_loess &lt;- sim1a %&gt;% add_predictions(sim1_loess) sim1a &lt;- sim1a %&gt;% add_residuals(sim1_lm) %&gt;% add_predictions(sim1_lm) %&gt;% add_residuals(sim1_loess, var = &quot;resid_loess&quot;) %&gt;% add_predictions(sim1_loess, var = &quot;pred_loess&quot;) Ahora procedemos a graficar las predicciones. La regresión loess genera un ajuste no lineal a partir de los datos. plot_sim1_loess &lt;- ggplot(sim1, aes(x = x, y = y)) + geom_point() + geom_line(aes(x = x, y = pred), data = grid_loess, colour = &quot;red&quot;) plot_sim1_loess Las predicciones del modelo loess son las mismas que entrega el método por defecto de geom_smooth() ya que este usa loess() y entrega un mensaje al respecto. plot_sim1_loess + geom_smooth(method = &quot;loess&quot;, colour = &quot;blue&quot;, se = FALSE, alpha = 0.20) #&gt; `geom_smooth()` using formula &#39;y ~ x&#39; Podemos graficar los residuos de loess (en rojo) y compararlos con los del modelo lineal (en negro). En general, el modelo loess tiene un menor residuo dada la muestra (fuera de la muestra no se asegura este comportamiento y no hemos considerado la incertidumbre de la estimación). ggplot(sim1a, aes(x = x)) + geom_ref_line(h = 0) + geom_point(aes(y = resid)) + geom_point(aes(y = resid_loess), colour = &quot;red&quot;) add_predictions() está pareada con gather_predictions() y spread_predictions(). ¿Cómo difieren estas tres funciones? Solución Las funciones gather_predictions() y spread_predictions() permiten incluir simultáneamente las predicciones de múltiples modelos. Por ejemplo, se puede incluir sim1_mod. sim1_mod &lt;- lm(y ~ x, data = sim1) grid &lt;- sim1 %&gt;% data_grid(x) La función add_predictions() permite incluir un modelo a la vez. Para agregar dos modelos se debe encadenar con el operador %&gt;%. grid %&gt;% add_predictions(sim1_mod, var = &quot;pred_lm&quot;) %&gt;% add_predictions(sim1_loess, var = &quot;pred_loess&quot;) #&gt; # A tibble: 10 × 3 #&gt; x pred_lm pred_loess #&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 6.27 7.05 #&gt; 2 2 8.32 8.76 #&gt; 3 3 10.4 10.5 #&gt; 4 4 12.4 12.1 #&gt; 5 5 14.5 14.1 #&gt; 6 6 16.5 15.9 #&gt; # … with 4 more rows La función gather_predictions() incorpora predicciones de múltiples modelos por medio de agrupar los resultados e incluir una columna con el nombre del modelo. grid %&gt;% gather_predictions(sim1_mod, sim1_loess) #&gt; # A tibble: 20 × 3 #&gt; model x pred #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 sim1_mod 1 6.27 #&gt; 2 sim1_mod 2 8.32 #&gt; 3 sim1_mod 3 10.4 #&gt; 4 sim1_mod 4 12.4 #&gt; 5 sim1_mod 5 14.5 #&gt; 6 sim1_mod 6 16.5 #&gt; # … with 14 more rows La función spread_predictions() incorpora predicciones de múltiples modelos agregando múltiples columnas (de acuerdo al nombre de cada modelo) que contienen las predicciones respectivas. grid %&gt;% spread_predictions(sim1_mod, sim1_loess) #&gt; # A tibble: 10 × 3 #&gt; x sim1_mod sim1_loess #&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 6.27 7.05 #&gt; 2 2 8.32 8.76 #&gt; 3 3 10.4 10.5 #&gt; 4 4 12.4 12.1 #&gt; 5 5 14.5 14.1 #&gt; 6 6 16.5 15.9 #&gt; # … with 4 more rows La función spread_predictions() es similar a correr add_predictions() para cada modelo que se quiere incorporar y es equivalente a correr spread() luego de gather_predictions(). grid %&gt;% gather_predictions(sim1_mod, sim1_loess) %&gt;% spread(model, pred) #&gt; # A tibble: 10 × 3 #&gt; x sim1_loess sim1_mod #&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 7.05 6.27 #&gt; 2 2 8.76 8.32 #&gt; 3 3 10.5 10.4 #&gt; 4 4 12.1 12.4 #&gt; 5 5 14.1 14.5 #&gt; 6 6 15.9 16.5 #&gt; # … with 4 more rows ¿Qué hace geom_ref_line()? ¿De qué paquete proviene? ¿Por qué es útil e importante incluir una línea de referencia en los gráficos que muestran residuos? Solución La geometría geom_ref_line() agrega una línea de referencia al gráfico. Es el equivalente a usar geom_hline() o geom_vline() con las opciones por defecto y que nos sirven para visualizar modelos. Agregar una línea de referencia en torno a cero para los residuos es importante ya que un buen modelo, por lo general, tiene residuos centrados en torno a cero. Otras características relevantes son que los errores deben tener idéntica varianza y no estar correlacionados entre si. La línea de referencia en torno a cero permite evaluar visualmente estas características. ¿Por qué quisieras mirar un polígono de frecuencias con los residuos absolutos? ¿Cuáles son las ventajas y desventajas de los residuos crudos? Solución Mostrar los valores absolutos de los residuos facilita ver la magnitud del error. El modelo lineal asume que los residuos tienen media cero y usar los valores absolutos de los residuos permite ver lo que ocurre cuando los errores de signos opuestos no se cancelan mutuamente. sim1_mod &lt;- lm(y ~ x, data = sim1a) sim1 &lt;- sim1 %&gt;% add_residuals(sim1_mod) ggplot(sim1a, aes(x = abs(resid))) + geom_freqpoly(binwidth = 0.5) El inconveniente que aparece visualmente es que se pierde toda información respecto de los signos de los residuos. Por lo tanto, el polígono de frecuencias no distingue si acaso el modelo sobre-estima o sub-estima de manera consistente. 23.4 Fórmulas y familias de modelos 23.4.5 Ejercicios ¿Qué pasa si repites el análisis de sim2 usando un modelo sin intercepto? ¿Qué ocurre con la ecuación del modelo? ¿Qué ocurre con las predicciones? Solución Para estimar el modelo sin intercepto agregamos -1 o +0 al lado derecho de la fórmula. mod2a &lt;- lm(y ~ x - 1, data = sim2) mod2 &lt;- lm(y ~ x, data = sim2) Las predicciones son las mismas en el caso con o sin intercepto: grid &lt;- sim2 %&gt;% data_grid(x) %&gt;% spread_predictions(mod2, mod2a) grid #&gt; # A tibble: 4 × 3 #&gt; x mod2 mod2a #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 a 1.15 1.15 #&gt; 2 b 8.12 8.12 #&gt; 3 c 6.13 6.13 #&gt; 4 d 1.91 1.91 Usa model_matrix() para explorar las ecuaciones generadas por los modelos ajustados a sim3 y sim4. ¿Por qué * es un atajo para la interacción? Solución El caso x1 * x2 cuando x2 es una variable categórica produce las variables binarias x2b, x2c y x2d y las variables continuas x1:x2b, x1:x2c y x1:x2d que son el producto de x1 y x2*. x3 &lt;- model_matrix(y ~ x1 * x2, data = sim3) x3 #&gt; # A tibble: 120 × 8 #&gt; `(Intercept)` x1 x2b x2c x2d `x1:x2b` `x1:x2c` `x1:x2d` #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 1 0 0 0 0 0 0 #&gt; 2 1 1 0 0 0 0 0 0 #&gt; 3 1 1 0 0 0 0 0 0 #&gt; 4 1 1 1 0 0 1 0 0 #&gt; 5 1 1 1 0 0 1 0 0 #&gt; 6 1 1 1 0 0 1 0 0 #&gt; # … with 114 more rows Podemos confirmar que las variables x1:x2b son el producto de x1 y x2b. all(x3[[&quot;x1:x2b&quot;]] == (x3[[&quot;x1&quot;]] * x3[[&quot;x2b&quot;]])) #&gt; [1] TRUE Es similar para x1:x2c y x2c como para el caso de x1:x2d y x2d. all(x3[[&quot;x1:x2c&quot;]] == (x3[[&quot;x1&quot;]] * x3[[&quot;x2c&quot;]])) #&gt; [1] TRUE all(x3[[&quot;x1:x2d&quot;]] == (x3[[&quot;x1&quot;]] * x3[[&quot;x2d&quot;]])) #&gt; [1] TRUE Para x1 * x2 cuando x1 y x2 son continuas, model_matrix() creas las variables x1, x2 y x1:x2. x4 &lt;- model_matrix(y ~ x1 * x2, data = sim4) x4 #&gt; # A tibble: 300 × 4 #&gt; `(Intercept)` x1 x2 `x1:x2` #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 -1 -1 1 #&gt; 2 1 -1 -1 1 #&gt; 3 1 -1 -1 1 #&gt; 4 1 -1 -0.778 0.778 #&gt; 5 1 -1 -0.778 0.778 #&gt; 6 1 -1 -0.778 0.778 #&gt; # … with 294 more rows Se puede confirmar que x1:x2 es el producto de x1 y x2. all(x4[[&quot;x1&quot;]] * x4[[&quot;x2&quot;]] == x4[[&quot;x1:x2&quot;]]) #&gt; [1] TRUE Usando los principios básicos, convierte las fórmulas de los siguientes modelos en funciones. (Sugerencia: comienza por convertir las variables categóricas en ceros y unos.) mod1 &lt;- lm(y ~ x1 + x2, data = sim3) mod2 &lt;- lm(y ~ x1 * x2, data = sim3) Solución El lado derecho de las fórmulas se encarga de generar una matriz de diseño a partir de las columnas x1 y x2, lo que se ve reflejado en model_matrix(). Veamos los niveles de x2, que por ser una variable categórica es la más compleja de llevar a la matriz de diseño. x1 permanece inalterada. levels(sim3$x2) #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; Para el caso ~ x1 + x2 lo que haremos es considerar “a” como el nivel de referencia, por lo que se omite, y luego generamos nuevas columnas para los niveles “b”, “c” y “d”. model_matrix_mod1 &lt;- function(.data) { mutate(.data, x2b = as.numeric(x2 == &quot;b&quot;), x2c = as.numeric(x2 == &quot;c&quot;), x2d = as.numeric(x2 == &quot;d&quot;), `(Intercept)` = 1 ) %&gt;% select(`(Intercept)`, x1, x2b, x2c, x2d) } model_matrix_mod1(sim3) #&gt; # A tibble: 120 × 5 #&gt; `(Intercept)` x1 x2b x2c x2d #&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 1 0 0 0 #&gt; 2 1 1 0 0 0 #&gt; 3 1 1 0 0 0 #&gt; 4 1 1 1 0 0 #&gt; 5 1 1 1 0 0 #&gt; 6 1 1 1 0 0 #&gt; # … with 114 more rows Es posible crear función para ~ x1 + x2 que no depende de los niveles específicos de x2. model_matrix_mod1b &lt;- function(.data) { # niveles de x2 lvls &lt;- levels(.data$x2) # borramos el primer nivel (es de referencia) # asumimos que hay al menos dos niveles lvls &lt;- lvls[2:length(lvls)] # creamos una variable binaria para cada nivel de x2 for (lvl in lvls) { varname &lt;- str_c(&quot;x2&quot;, lvl) .data[[varname]] &lt;- as.numeric(.data$x2 == lvl) } # generamos una lista de las variables que se mantienen x2_variables &lt;- str_c(&quot;x2&quot;, lvls) # agregamos el intercepto .data[[&quot;(Intercept)&quot;]] &lt;- 1 # mantenemos las variables binarias x1 y x2 select(.data, `(Intercept)`, x1, one_of(x2_variables)) } model_matrix_mod1b(sim3) #&gt; # A tibble: 120 × 5 #&gt; `(Intercept)` x1 x2b x2c x2d #&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 1 0 0 0 #&gt; 2 1 1 0 0 0 #&gt; 3 1 1 0 0 0 #&gt; 4 1 1 1 0 0 #&gt; 5 1 1 1 0 0 #&gt; 6 1 1 1 0 0 #&gt; # … with 114 more rows Para el caso ~ x1 * x2 hay que tener en cuenta que debemos generar una columna por cada nivel de x2, sin contar el nivel de referencia que interactúa con x1. model_matrix_mod2 &lt;- function(.data) { mutate(.data, `(Intercept)` = 1, x2b = as.numeric(x2 == &quot;b&quot;), x2c = as.numeric(x2 == &quot;c&quot;), x2d = as.numeric(x2 == &quot;d&quot;), `x1:x2b` = x1 * x2b, `x1:x2c` = x1 * x2c, `x1:x2d` = x1 * x2d ) %&gt;% select(`(Intercept)`, x1, x2b, x2c, x2d, `x1:x2b`, `x1:x2c`, `x1:x2d`) } model_matrix_mod2(sim3) #&gt; # A tibble: 120 × 8 #&gt; `(Intercept)` x1 x2b x2c x2d `x1:x2b` `x1:x2c` `x1:x2d` #&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 1 0 0 0 0 0 0 #&gt; 2 1 1 0 0 0 0 0 0 #&gt; 3 1 1 0 0 0 0 0 0 #&gt; 4 1 1 1 0 0 1 0 0 #&gt; 5 1 1 1 0 0 1 0 0 #&gt; 6 1 1 1 0 0 1 0 0 #&gt; # … with 114 more rows Es posible crear una función para ~ x1 * x2 que no depende de los niveles específicos de x2. model_matrix_mod2b &lt;- function(.data) { # partimos de la base del modelo x1 + x2 out &lt;- model_matrix_mod1b(.data) # tomamos las columnas que contienen &quot;x2&quot; x2cols &lt;- str_subset(colnames(out), &quot;^x2&quot;) # creamos las variables de interacción for (varname in x2cols) { newvar &lt;- str_c(&quot;x1:&quot;, varname) out[[newvar]] &lt;- out$x1 * out[[varname]] } out } model_matrix_mod2b(sim3) #&gt; # A tibble: 120 × 8 #&gt; `(Intercept)` x1 x2b x2c x2d `x1:x2b` `x1:x2c` `x1:x2d` #&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 1 0 0 0 0 0 0 #&gt; 2 1 1 0 0 0 0 0 0 #&gt; 3 1 1 0 0 0 0 0 0 #&gt; 4 1 1 1 0 0 1 0 0 #&gt; 5 1 1 1 0 0 1 0 0 #&gt; 6 1 1 1 0 0 1 0 0 #&gt; # … with 114 more rows Estas funciones se podrían generalizar para los casos en que x1 y x2 pueden ser de tipo numérico o categórico. Si seguimos generalizando acabaremos reescribiendo la función matrix_model(). Para sim4, ¿Es mejor mod1 o mod2? Yo creo que mod2 es ligeramente mejor removiendo las tendencias, pero es bastante sutil. ¿Puedes generar un gráfico que de sustento a esta hipótesis? Solución Estimamos los modelos mod1 y mod2 a partir de sim4, mod1 &lt;- lm(y ~ x1 + x2, data = sim4) mod2 &lt;- lm(y ~ x1 * x2, data = sim4) Luego agregamos los residuos a los datos de sim4. sim4_mods &lt;- gather_residuals(sim4, mod1, mod2) Ahora podemos generar un gráfico de frecuencias de los residuos y los valores absolutos de estos. ggplot(sim4_mods, aes(x = resid, colour = model)) + geom_freqpoly(binwidth = 0.5) + geom_rug() ggplot(sim4_mods, aes(x = abs(resid), colour = model)) + geom_freqpoly(binwidth = 0.5) + geom_rug() Esto no muestra una gran diferencia. Sin embargo, mod2 parece tener menos residuos en las colas de la distribución entre 2,5 y 5, aunque los residuos más extremos son los de este modelo. Podemos verificar lo anterior calculando la desviación estándar de los residuos para cada modelo. sim4_mods %&gt;% group_by(model) %&gt;% summarise(resid = sd(resid)) #&gt; # A tibble: 2 × 2 #&gt; model resid #&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 mod1 2.10 #&gt; 2 mod2 2.07 La desviación estándar de los residuos de mod2 es menor que la de mod1. "],["construcción-de-modelos.html", "24 Construcción de modelos 24.2 ¿Por qué los diamantes de baja calidad son más caros? 24.3 ¿Qué afecta el número de vuelos diarios?", " 24 Construcción de modelos 24.2 ¿Por qué los diamantes de baja calidad son más caros? 24.2.3 Ejercicios En el gráfico de log_quilates vs. log_precio, hay unas tiras verticales brillantes. ¿Qué representan? Solución Si log(precio) = a_0 + a_1 * log(quilates), ¿Qué dice eso acerca la relación entre precio y quilates? Solución Extrae los diamantes que tienen residuos muy altos y muy bajos. ¿Hay algo inusual en estos diamantes? ¿Son particularmente malos o buenos?, o ¿Crees que estos son errores de precio? Solución ¿El modelo final, mod_diamantes2, hace un buen trabajo al predecir el precios de los diamantes? ¿Confiarías en lo que te indique gastar si fueras a comprar un diamante? Solución 24.3 ¿Qué afecta el número de vuelos diarios? 24.3.5 Ejercicios Usa tus habilidades detectivescas con los buscadores para intercambiar ideas sobre por qué hubo menos vuelos esperados el 20 de enero, 26 de mayo y 1 de septiembre. (Pista: todos tienen la misma explicación.) ¿Cómo generalizarías esos días a otros años? Solución ¿Qué representan esos tres días con altos residuos positivos? ¿Cómo se generalizarían esos días a otros años? vuelos_por_dia %&gt;% top_n(3, resid) Solución Crea una nueva variable que divida la variable dia_semana en periodos, pero sólo para sábados, es decir, debería tener Thu, Fri, y Sat-verano, Sat-primavera, Sat-otonio. ¿Cómo este modelo se compara con el modelo que tiene la combinación de dia_semana y trimestre? Solución Crea una nueva variable dia_semana que combina el día de la semana, periodos (para sábados), y feriados públicos. ¿Cómo se ven los residuos de este modelo? Solución ¿Qué sucede si ajustas un efecto de día de la semana que varía según el mes o varía mes a mes (es decir, n ~ dia_semana * month)? ¿Por qué esto no es muy útil? Solución ¿Que esperarías del modelo n ~ dia_semana + ns(fecha, 5)? Sabiendo lo que sabes sobre los datos, ¿porqué esperarias que no sea particularmente efectivo? Solución Presumimos que las personas que salen los domingos son probablemente viajeros de negocios quienes necesitan estar en algun lugar el lunes. Explora esa hipótesis al ver cómo se descompone en función de la distancia y tiempo: si es verdad, esperarías ver más vuelos en la tarde del domingo a lugares que estan muy lejos. Solución Es un poco frustante que el domingo y sábado esté en los extremos opuestos del gráfico. Escribe una pequeña función para establecer los niveles del factor para que la semana comience el lunes. Solución "],["muchos-modelos.html", "25 Muchos modelos 25.2 gapminder 25.4 Creando columnas-lista 25.5 Simplificando columnas-lista", " 25 Muchos modelos 25.2 gapminder 25.2.5 Ejercicios Una tendencia lineal parece ser demasiado simple para la tendencia general. ¿Puedes hacerlo mejor con un polinomio cuadrático? ¿Cómo puedes interpretar el coeficiente del término cuadrático? (Pista: puedes querer transformar year para que tenga media cero.) Solución El siguiente código replica el análisis que se hizo en el libro pero cambia l función modelo_pais() para incluir una regresión que incluye el año al cuadrado. modelo_pais_2 &lt;- function(df) { lm(esperanza_de_vida ~ poly(anio - median(anio), 2), data = df) } por_pais &lt;- paises %&gt;% group_by(pais, continente) %&gt;% nest() por_pais &lt;- por_pais %&gt;% mutate(modelo = map(data, modelo_pais_2)) por_pais &lt;- por_pais %&gt;% mutate( residuo = map2(data, modelo, add_residuals) ) por_pais #&gt; # A tibble: 142 × 5 #&gt; # Groups: pais, continente [142] #&gt; pais continente data modelo residuo #&gt; &lt;fct&gt; &lt;fct&gt; &lt;list&gt; &lt;list&gt; &lt;list&gt; #&gt; 1 Afganistán Asia &lt;tibble [12 × 4]&gt; &lt;lm&gt; &lt;tibble [12 × 5]&gt; #&gt; 2 Albania Europa &lt;tibble [12 × 4]&gt; &lt;lm&gt; &lt;tibble [12 × 5]&gt; #&gt; 3 Argelia África &lt;tibble [12 × 4]&gt; &lt;lm&gt; &lt;tibble [12 × 5]&gt; #&gt; 4 Angola África &lt;tibble [12 × 4]&gt; &lt;lm&gt; &lt;tibble [12 × 5]&gt; #&gt; 5 Argentina Américas &lt;tibble [12 × 4]&gt; &lt;lm&gt; &lt;tibble [12 × 5]&gt; #&gt; 6 Australia Oceanía &lt;tibble [12 × 4]&gt; &lt;lm&gt; &lt;tibble [12 × 5]&gt; #&gt; # … with 136 more rows unnest(por_pais, residuo) %&gt;% ggplot(aes(anio, resid)) + geom_line(aes(group = pais), alpha = 1 / 3) + geom_smooth(se = FALSE) #&gt; `geom_smooth()` using method = &#39;gam&#39; and formula &#39;y ~ s(x, bs = &quot;cs&quot;)&#39; por_pais %&gt;% mutate(estadistica = map(modelo, broom::glance)) %&gt;% unnest(estadistica, .drop = TRUE) %&gt;% ggplot(aes(continente, r.squared)) + geom_jitter(width = 0.5) #&gt; Warning: The `.drop` argument of `unnest()` is deprecated as of tidyr 1.0.0. #&gt; All list-columns are now preserved. #&gt; This warning is displayed once every 8 hours. #&gt; Call `lifecycle::last_lifecycle_warnings()` to see where this warning was generated. Explora otros métodos para visualizar la distribución del \\(R^2\\) por continente. Puedes querer probar el paquete ggbeeswarm, que provee métodos similares para evitar superposiciones como jitter, pero usa métodos determinísticos. Solución El paquete gbeeswarm se usó en el capítulo de análisis exploratorio. por_pais %&gt;% mutate(estadistica = map(modelo, broom::glance)) %&gt;% unnest(estadistica, .drop = TRUE) %&gt;% ggplot(aes(continente, r.squared)) + geom_beeswarm() Para crear el último gráfico (mostrando los datos para los países con los peores ajustes del modelo), precisamos dos pasos: creamos un data frame con una fila por país y después hicimos un semi-join (del inglés semi juntar) (TODO: deberíamos aclarar algo?) al conjunto de datos original. Es posible evitar este join si usamos unnest() en lugar de unnest(.drop = TRUE). ¿Cómo? Solución paises %&gt;% group_by(pais, continente) %&gt;% nest() %&gt;% mutate(modelo = map(data, ~lm(esperanza_de_vida ~ anio, .))) %&gt;% mutate(estadistica = map(modelo, broom::glance)) %&gt;% unnest(estadistica) %&gt;% unnest(data) %&gt;% filter(r.squared &lt; 0.25) %&gt;% ggplot(aes(anio, esperanza_de_vida)) + geom_line(aes(color = pais)) 25.4 Creando columnas-lista 25.4.5 Ejercicios Lista todas las funciones en las que puedas pensar que tomen como input un vector atómico y retornen una lista. Solución Muchas funciones del paquete stringr cumplen con el criterio. str_split(sentences[1:3], &quot; &quot;) #&gt; [[1]] #&gt; [1] &quot;The&quot; &quot;birch&quot; &quot;canoe&quot; &quot;slid&quot; &quot;on&quot; &quot;the&quot; &quot;smooth&quot; #&gt; [8] &quot;planks.&quot; #&gt; #&gt; [[2]] #&gt; [1] &quot;Glue&quot; &quot;the&quot; &quot;sheet&quot; &quot;to&quot; &quot;the&quot; #&gt; [6] &quot;dark&quot; &quot;blue&quot; &quot;background.&quot; #&gt; #&gt; [[3]] #&gt; [1] &quot;It&#39;s&quot; &quot;easy&quot; &quot;to&quot; &quot;tell&quot; &quot;the&quot; &quot;depth&quot; &quot;of&quot; &quot;a&quot; &quot;well.&quot; str_match_all(c(&quot;paul&quot;, &quot;john&quot;, &quot;george&quot;, &quot;ringo&quot;), &quot;a+&quot;) #&gt; [[1]] #&gt; [,1] #&gt; [1,] &quot;a&quot; #&gt; #&gt; [[2]] #&gt; [,1] #&gt; #&gt; [[3]] #&gt; [,1] #&gt; #&gt; [[4]] #&gt; [,1] En el caso del paquete purrr, la función map() también cumple el criterio. map(1:3, runif) #&gt; [[1]] #&gt; [1] 0.601 #&gt; #&gt; [[2]] #&gt; [1] 0.1572 0.0074 #&gt; #&gt; [[3]] #&gt; [1] 0.466 0.498 0.290 Piensa en funciones de resumen útiles que, como quantile(), retornen múltiples valores. Solución Algunos ejemplos de funciones básicas de R que cumplen con el criterio. range(mtcars$mpg) #&gt; [1] 10.4 33.9 fivenum(mtcars$mpg) #&gt; [1] 10.4 15.3 19.2 22.8 33.9 boxplot.stats(mtcars$mpg) #&gt; $stats #&gt; [1] 10.4 15.3 19.2 22.8 33.9 #&gt; #&gt; $n #&gt; [1] 32 #&gt; #&gt; $conf #&gt; [1] 17.1 21.3 #&gt; #&gt; $out #&gt; numeric(0) ¿Qué es lo que falta en el siguiente data frame? ¿Cómo quantile() retorna eso que falta? ¿Por qué eso no es tan útil aquí? mtautos %&gt;% group_by(cilindros) %&gt;% summarise(q = list(quantile(millas))) %&gt;% unnest() #&gt; Warning: `cols` is now required when using unnest(). #&gt; Please use `cols = c(q)` #&gt; # A tibble: 15 × 2 #&gt; cilindros q #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 4 21.4 #&gt; 2 4 22.8 #&gt; 3 4 26 #&gt; 4 4 30.4 #&gt; 5 4 33.9 #&gt; 6 6 17.8 #&gt; # … with 9 more rows Solución No se muestran los cuartiles correspondientes. Esto se debe a que la función quantile() entrega los valores 0%, 25%, 50%, 75%, 100% como nombres del vector resultante y unnest() descarta los nombres del vector. quantile(mtcars$mpg) #&gt; 0% 25% 50% 75% 100% #&gt; 10.4 15.4 19.2 22.8 33.9 ¿Qué hace este código? ¿Por qué podría ser útil? mtautos %&gt;% group_by(cilindros) %&gt;% summarise_each(funs(list)) Solución Crea un cuadro de datos en el que cada fila corresponde a un valor unico de cilindros y cada observación fuera de la primera columna es un vector. La utilidad es que reune las observaciones para cada variable y las agrupa, lo que puede simplificar algunos análisis particulares en los que se quiera analizar todas las observaciones agrupando por número de cilindros. 25.5 Simplificando columnas-lista 25.5.3 Ejercicios ¿Por qué podría ser útil la función lengths() para crear columnas de vectores atómicos a partir de columnas-lista? Solución La función lengths() entreg el largo de cada elemento en una lista. Proporciona un atajo a map_int(x, length) y sapply(x, length). Es útil para verificar si acaso los elementos de una columna de tipo lista son todos del mismo largo. Otra posibilidad es calcular el máximo largo dentro de la columna y así sabremos cuántas columnas debo crear para transformar en varias columnas atómicas. Lista los tipos de vectores más comúnes que se encuentran en un data frame. ¿Qué hace que las listas sean diferentes? Solución Los tipos más comunes de vectores en un cuadro de datos son: logical numeric integer character factor Todos estos tipos son atómicos. Las listas no son atómicas ya que pueden contener otras listas o vectores. "],["introducción-8.html", "26 Introducción", " 26 Introducción Esta sección no tiene ejercicios. "],["r-markdown.html", "27 R Markdown 27.2 R Markdown básico 27.3 Formateo de texto con Markdown 27.4 Bloques de código", " 27 R Markdown 27.2 R Markdown básico 27.2.1 Ejercicios Crea un nuevo notebook usando File &gt; New File &gt; R Notebook. Lee las instrucciones. Practica ejecutando los bloques. Verifica que puedes modificar el código, re-ejecútalo, y observa la salida modificada. Solución Crea un nuevo documento R Markdown con File &gt; New File &gt; R Markdown… Haz clic en el icono apropiado de Knit. Haz Knit usando el atajo de teclado apropiado. Verifica que puedes modificar el input y la actualizacion del output. Solución Compara y contrasta el notebook de R con los archivos de R markdown que has creado antes. ¿Cómo son similares los outputs? ¿Cómo son diferentes? ¿Cómo son similares los inputs? ¿En qué se diferencian? ¿Qué ocurre si copias el encabezado YAML de uno al otro? Solución Crea un nuevo documento R Markdown para cada uno de los tres formatos incorporados: HTML, PDF and Word. Haz knit en cada uno de estos tres documentos. ¿Como difiere el output? ¿Cómo difiere el input? (Puedes necesitar instalar LaTeX para poder compilar el output en PDF— RStudio preguntará si esto es necesario). Solución 27.3 Formateo de texto con Markdown 27.3.1 Ejercicios Practica lo que has aprendido crando un CV breve. El título debería ser tu nombre, y deberías incluir encabezados para (por lo menos) educación o empleo. Cada una de las secciones debería incluir una lista con viñetas de trabajos/ títulos obtenidos. Resalta año en negrita. Solución Usando la referencia rapida de R Markdown, descubre como: 1. Agregar una nota al pie. 1. Agregar una linea horizontal. 1. Agregar una cita en bloque. Solución Copia y pega los contenidos de diamond-sizes.Rmd desde https://github.com/hadley/r4ds/tree/master/rmarkdown a un documento local de R Markdown. Revisa que puedes ejecutarlo, agrega texto despues del poligono de frecuencias que describa sus características más llamativas. Solución 27.4 Bloques de código 27.4.7 Ejercicios Incluye una seccion que explore como los tamaños de diamantes varian por corte, color y claridad. Asume que escribes un reporte para alguien que no conoce R, y en lugar de fijar echo = FALSE en cada bloque, fijar una opción global. Solución Descarga diamond-sizes.Rmd de https://github.com/hadley/r4ds/tree/master/rmarkdown. Agrega una sección que describa los 20 diamantes mas grandes, incluyendo una tabla que muestre sus atributos más importantes. Solución Modifica diamonds-sizes.Rmd para usar comma() para producir un formato de output ordenado. También incluye el porcentaje de diamantes que son mayores a 2.5 quilates. Solución Fija una red de bloques donde d depende de c y b, y tanto b y c dependen de a. Haz que cada bloque imprima lubridate::now(), fijar cache = TRUE, y verifica entonces tu comprensión del almacenamiento en cache. Solución "],["comunicar-con-gráficos.html", "28 Comunicar con gráficos 2.8 Etiquetas 28.3 Anotaciones 28.4 Escalas", " 28 Comunicar con gráficos 2.8 Etiquetas 28.2.1 Ejercicios Crea un gráfico partiendo de los datos de economía de combustible (datos::millas) con etiquetas para title , subtitle, caption, x, y y color personalizadas. Solución La función geom_smooth() es un poco engañosa porque autopista está sesgada positivamente para motores grandes, debido a la inclusión de autos deportivos livianos con motores grandes. Usa tus herramientas de modelado para ajustar y mostrar un modelo mejor. Solución Elige un gráfico exploratorio que hayas creado en el último mes y agrégale títulos informativos para volverlo más fácil de comprender para otros. Solución 28.3 Anotaciones 28.3.1 Ejercicios Usa las infinitas posiciones que permite geom_text() para colocar texto en cada una de las cuatro esquinas del gráfico. Solución Lee la documentación de la función annotate(). ¿Cómo puedes usarla para agregar una etiqueta de texto a un gráfico sin tener que crear un tibble? Solución ¿Cómo interactúan las etiquetas producidas por geom_text() con la separación en facetas? ¿Cómo puedes agregar una etiqueta a una sola faceta? ¿Cómo puedes poner una etiqueta diferente en cada faceta? (Sugerencia: piensa en los datos subyacentes). Solución ¿Qué argumentos para geom_label() controlan la apariencia de la caja que se ve atrás? Solución ¿Cuáles son los cuatro argumentos de arrow()? ¿Cómo funcionan? Crea una serie de gráficos que demuestren las opciones más importantes. Solución Los cuatro argumentos de grid::arrow() son: angle: el ańgulo de la punta de la flecha en grados. length: el largo de la punta de la flecha desde la punta a la base. ends: “last”, “first” o “both”, dependiendo de en qué extremo de la flecha queremos que se dibuje la punta. type: “open” o “closed”, dependiendo de si queremos que la punta de la flecha sea un triángulo abierto o cerrado. Para ilustrar su uso, utilizaremos las opciones de arrow dentro de geom_segment: grafico &lt;- paises %&gt;% filter(pais == &quot;Ruanda&quot;) %&gt;% ggplot(aes(anio, esperanza_de_vida)) + geom_line(colour = &quot;#5cb85c&quot;) + labs(title = &quot;Evolución de la esperanza de vida en Ruanda entre 1952 y 2007&quot;, x = &quot;Año&quot;, y = &quot;Edad&quot;) + ylim(20,80) + theme_minimal() grafico + geom_segment(aes(x = 1980, xend = 1988, y = 24, yend = 24), arrow = arrow(angle = 40, length = unit(0.1, &quot;cm&quot;), type = &quot;closed&quot;), colour = &quot;gray51&quot;) + annotate(&quot;text&quot;, x = 1975, y = 24, label = &quot;Guerra Civil&quot;, colour = &quot;gray51&quot;) Veamos otras opciones para ajustar la flecha. En esta ocasión tendremos que modificar el valor de ends que viene por defecto grafico + geom_segment(aes(x = 1992.5, xend = 1995, y = 30, yend = 50), arrow = arrow(angle = 40, length = unit(0.2, &quot;cm&quot;), ends = &quot;first&quot;, type = &quot;open&quot;), colour = &quot;gray51&quot;) + annotate(&quot;text&quot;, x = 1995, y = 52, label = &quot;Guerra Civil&quot;, colour = &quot;gray51&quot;) 28.4 Escalas 28.4.4 Ejercicios ¿Por qué el siguiente código no reemplaza la escala predeterminada? df &lt;- tibble( x = rnorm(10000), y = rnorm(10000) ) ggplot(df, aes(x, y)) + geom_hex() + scale_colour_gradient(low = &quot;white&quot;, high = &quot;red&quot;) + coord_fixed() Solución La escala predeterminada no se ve modificada porque en el caso de geom_hex() tenemos que utilizar scale_fill_gradient(): ggplot(df, aes(x, y)) + geom_hex() + scale_fill_gradient(low = &quot;white&quot;, high = &quot;red&quot;) + coord_fixed() ¿Cuál es el primer argumento para cada escala? ¿Cómo se compara con labs()? Solución Cambia la visualización de los periodos presidenciales (datos::presidencial) de las siguientes maneras: Combinando las dos variantes que se muestran arriba. Mejorando la visualización del eje y. Etiquetando cada término con el nombre del presidente. Agregando etiquetas informativas al gráfico. Poniendo intervalos de 4 años (¡esto es más complicado de lo que parece!). Solución Las dos versiones a las que hace alusión el punto I son las siguientes: presidencial %&gt;% mutate(id = 33 + row_number()) %&gt;% ggplot(aes(inicio, id)) + geom_point() + geom_segment(aes(xend = fin, yend = id)) + scale_x_date(NULL, breaks = presidencial$inicio, date_labels = &quot;&#39;%y&quot;) presidencial %&gt;% mutate(id = 33 + row_number()) %&gt;% ggplot(aes(inicio, id, colour = partido)) + geom_point() + geom_segment(aes(xend = fin, yend = id)) + scale_colour_manual(values = c(Republicano = &quot;red&quot;, `Demócrata` = &quot;blue&quot;)) Primero, combinémoslas: presidencial %&gt;% mutate(id = 33 + row_number()) %&gt;% ggplot(aes(inicio, id, colour = partido)) + geom_point() + scale_x_date(NULL, breaks = presidencial$inicio, date_labels = &quot;&#39;%y&quot;) + geom_segment(aes(xend = fin, yend = id)) + scale_colour_manual(values = c(Republicano = &quot;red&quot;, `Demócrata` = &quot;blue&quot;)) Listo. Ahora, mejoremos la visualización del eje y, como indica el punto II. El eje y indica a qué número de mandatario corresponde (el dataset va desde Eisenhower, el presidente número 34, a Obama, el número 44). Lo ideal sería que en el eje y apareciera cada mandatario. Para que mantenga el orden de aparición, utilizaremos fct_inorder(). Como hay dos presidentes distintos que comparten apellido, podemos agregar el id al nombre para que distinga entre el que fue el presindente 41° y el que fue 43°. presidencial %&gt;% mutate(id = 33 + row_number()) %&gt;% mutate(nombre = fct_inorder(str_c(nombre,&quot; (&quot;, id, &quot;°)&quot;))) %&gt;% ggplot(aes(inicio, nombre, colour = partido)) + geom_point() + scale_x_date(NULL, breaks = presidencial$inicio, date_labels = &quot;&#39;%y&quot;) + geom_segment(aes(xend = fin, yend = nombre)) + scale_colour_manual(values = c(Republicano = &quot;red&quot;, `Demócrata` = &quot;blue&quot;)) El punto III y IV hacen referencia a las etiquetas. En el paso anterior ya etiquetamos cada periodo presidencial con el nombre del mandatario. Agregar etiquetas al y sería un poco redundante (y lo será más cuando le pongamos título al gráfico). La del eje x se infiere, así que no agregaremos nada. presidencial %&gt;% mutate(id = 33 + row_number()) %&gt;% mutate(nombre = fct_inorder(str_c(nombre,&quot; (&quot;, id, &quot;°)&quot;))) %&gt;% ggplot(aes(inicio, nombre, colour = partido)) + geom_point() + scale_x_date(NULL, breaks = presidencial$inicio, date_labels = &quot;&#39;%y&quot;) + geom_segment(aes(xend = fin, yend = nombre)) + scale_colour_manual(values = c(Republicano = &quot;red&quot;, `Demócrata` = &quot;blue&quot;)) + labs(title = &quot;Presidentes de EE. UU. entre 1953 y 2017&quot;, y = NULL) Por último, tenemos que agregar intervalos de 4 años, que es lo que dura un período presidencial, así será posible ver quiénes estuvieron más de un período y quiénes no completaron el tiempo esperado. Para ello, usaremos el argumento date_minor_breaks dentro de scale_x_date(), que nos permite indicar intervalos con palabras (en este caso, “4 years”). presidencial %&gt;% mutate(id = 33 + row_number()) %&gt;% mutate(nombre = fct_inorder(str_c(nombre,&quot; (&quot;, id, &quot;°)&quot;))) %&gt;% ggplot(aes(inicio, nombre, colour = partido)) + geom_point() + scale_x_date(NULL, breaks = presidencial$inicio, date_labels = &quot;&#39;%y&quot;, date_minor_breaks = &quot;4 years&quot;) + geom_segment(aes(xend = fin, yend = nombre)) + scale_colour_manual(values = c(Republicano = &quot;red&quot;, `Demócrata` = &quot;blue&quot;)) + labs(title = &quot;Presidentes de EE. UU. entre 1953 y 2017&quot;, y = NULL) ¡Listo! Utiliza override.aes para que la leyenda en el siguiente gráfico sea más fácil de ver: ggplot(diamantes, aes(quilate, precio)) + geom_point(aes(colour = corte), alpha = 1 / 20) Solución El problema con estas etiquetas es que quedaron transparentes al haber utilizado alpha para ajustar la transparencia de los puntos. Si usamos override.aes al ajustar los parámetros de la leyenda podemos hacer que en ella los colores no sean transparentes. ggplot(diamantes, aes(quilate, precio)) + geom_point(aes(colour = corte), alpha = 1 / 20) + guides(colour = guide_legend(override.aes = list(alpha = 1))) "],["r-markdown-formats.html", "29 R Markdown formats", " 29 R Markdown formats Este capítulo no tiene ejercicios. "],["flujo-de-trabajo-en-r-markdown.html", "30 Flujo de trabajo en R Markdown", " 30 Flujo de trabajo en R Markdown Este capítulo no tiene ejercicios. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
